{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Smart-Geocubes","text":"<p>A high-performance library for intelligent loading and caching of remote geospatial raster data, built with xarray, zarr and icechunk.</p>"},{"location":"getting_started/","title":"Getting Started","text":"<p>Sorry, nothing to see here yet. Check back later! Until then, check the Reference.</p>"},{"location":"reference/smart_geocubes/","title":"smart_geocubes","text":""},{"location":"reference/smart_geocubes/#smart_geocubes","title":"smart_geocubes","text":"<p>Smart-Geocubes: A high-performance library for intelligent loading and caching of remote geospatial raster data, built with xarray and zarr.</p> <p>Modules:</p> <ul> <li> <code>accessors</code>           \u2013            <p>Smart-Geocubes cccessor implementations.</p> </li> <li> <code>concurrency</code>           \u2013            <p>Concurrency support for remote accessors.</p> </li> <li> <code>datasets</code>           \u2013            <p>Predefined datasets for the SmartGeocubes package.</p> </li> <li> <code>storage</code>           \u2013            <p>Local zarr-storage related functions.</p> </li> </ul>"},{"location":"reference/smart_geocubes/accessors/","title":"smart_geocubes.accessors","text":""},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors","title":"smart_geocubes.accessors","text":"<p>Smart-Geocubes cccessor implementations.</p> <p>Modules:</p> <ul> <li> <code>base</code>           \u2013            <p>Base class for remote accessors.</p> </li> <li> <code>gee</code>           \u2013            <p>Google Earth Engine Accessor for Smart Geocubes.</p> </li> <li> <code>stac</code>           \u2013            <p>STAC Accessor for Smart Geocubes.</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>GEEAccessor</code>           \u2013            <p>Accessor for Google Earth Engine data.</p> </li> <li> <code>RemoteAccessor</code>           \u2013            <p>Base class for remote accessors.</p> </li> <li> <code>STACAccessor</code>           \u2013            <p>Accessor for STAC data.</p> </li> </ul>"},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors.GEEAccessor","title":"GEEAccessor","text":"<pre><code>GEEAccessor(\n    storage: Storage | Path | str,\n    create_icechunk_storage: bool = True,\n    title: str | None = None,\n    extent: GeoBox | None = None,\n    chunk_size: int | None = None,\n    channels: list | None = None,\n    channels_meta: dict | None = None,\n    channels_encoding: dict | None = None,\n)\n</code></pre> <p>               Bases: <code>RemoteAccessor</code></p> <p>Accessor for Google Earth Engine data.</p> <p>Methods:</p> <ul> <li> <code>adjacent_tiles</code>             \u2013              <p>Get adjacent tiles from Google Earth Engine.</p> </li> <li> <code>current_state</code>             \u2013              <p>Get info about currently stored tiles.</p> </li> <li> <code>download_tile</code>             \u2013              <p>Download a tile from Google Earth Engine.</p> </li> </ul> Source code in <code>src/smart_geocubes/accessors/base.py</code> <pre><code>def __init__(\n    self,\n    storage: icechunk.Storage | Path | str,\n    create_icechunk_storage: bool = True,\n    title: str | None = None,\n    extent: GeoBox | None = None,\n    chunk_size: int | None = None,\n    channels: list | None = None,\n    channels_meta: dict | None = None,\n    channels_encoding: dict | None = None,\n):\n    \"\"\"Initialize base class for remote accessors.\n\n    !!! warning\n\n        In a multiprocessing environment, it is strongly recommended to not set `create_icechunk_storage=False`.\n\n    The arguments `title`, `extent`, `chunk_size`, `channels`, `channels_meta` and `channels_encoding`\n    will overwrite the dataset defaults and are only considered for the creation of a new datacube.\n    It is strongly recommended to not set these values manually.\n\n    Args:\n        storage (icechunk.Storage): The icechunk storage of the datacube.\n        create_icechunk_storage (bool, optional): If an icechunk repository should be created at provided storage\n            if no exists.\n            This should be disabled in a multiprocessing environment.\n            Defaults to True.\n        title (str | None, optional): The title of the datacube. Defaults to None.\n        extent (GeoBox | None, optional): The extent of the datacube. Defaults to None.\n        chunk_size (int | None, optional): The chunk size of the datacube. Defaults to None.\n        channels (list | None, optional): The channels of the datacube. Defaults to None.\n        channels_meta (dict | None, optional): The channels meta of the datacube. Defaults to None.\n        channels_encoding (dict | None, optional): The channels encoding of the datacube. Defaults to None.\n\n    Raises:\n        ValueError: If the storage is not an icechunk.Storage.\n\n    \"\"\"\n    if isinstance(storage, (str | Path)):\n        storage = storage if isinstance(storage, str) else str(storage.resolve())\n        storage = icechunk.local_filesystem_storage(storage)\n    if not isinstance(storage, icechunk.Storage):\n        raise ValueError(f\"Expected an icechunk.Storage, but got {type(storage)}\")\n    self.storage = storage\n    logger.debug(f\"Using storage {storage=}\")\n    if create_icechunk_storage:\n        self.repo = icechunk.Repository.open_or_create(storage)  # Will create a \"main\" branch\n    else:\n        self.repo = icechunk.Repository.open(storage)\n    logger.debug(f\"Using repository {self.repo=}\")\n\n    # We overwrite optionally the dataset attributes with user defined settings\n    self.title = title or type(self).__name__\n    if extent is not None:\n        self.extent = extent\n    if chunk_size is not None:\n        self.chunk_size = chunk_size\n    if channels is not None:\n        self.channels = channels\n    if channels_meta is not None:\n        self.channels_meta\n    if channels_encoding is not None:\n        self.channels_encoding\n\n    # TODO: store the settings variables in metadata and validate here\n\n    # The benchmarking timer for this accessor\n    self.stopuhr = StopUhr(logger.debug)\n\n    # The TypeVar used by the ThreadingHandler was added in 3.12\n    # The Shutdown method of the queue was added in 3.13\n    # Hence, we don't want to import the module unless Python 3.13 is installed\n    if _check_python_version(3, 13):\n        from smart_geocubes.concurrency.threading import ThreadingHandler\n\n        self.threading_handler = ThreadingHandler(self._threading_download)\n</code></pre>"},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors.GEEAccessor.adjacent_tiles","title":"adjacent_tiles","text":"<pre><code>adjacent_tiles(geobox: GeoBox) -&gt; list[TileWrapper]\n</code></pre> <p>Get adjacent tiles from Google Earth Engine.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[TileWrapper]</code>           \u2013            <p>list[TileWrapper]: List of adjacent tiles, wrapped in own datastructure for easier processing.</p> </li> </ul> Source code in <code>src/smart_geocubes/accessors/gee.py</code> <pre><code>def adjacent_tiles(self, geobox: GeoBox) -&gt; list[TileWrapper]:\n    \"\"\"Get adjacent tiles from Google Earth Engine.\n\n    Args:\n        geobox (GeoBox): The geobox for which to get adjacent tiles.\n\n    Returns:\n        list[TileWrapper]: List of adjacent tiles, wrapped in own datastructure for easier processing.\n\n    \"\"\"\n    tiles = GeoboxTiles(self.extent, (self.chunk_size, self.chunk_size))\n    return [TileWrapper(_tileidx_to_id(idx), tiles[idx]) for idx in tiles.tiles(geobox.extent)]\n</code></pre>"},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors.GEEAccessor.adjacent_tiles(geobox)","title":"<code>geobox</code>","text":"(<code>GeoBox</code>)           \u2013            <p>The geobox for which to get adjacent tiles.</p>"},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors.GEEAccessor.current_state","title":"current_state","text":"<pre><code>current_state() -&gt; gpd.GeoDataFrame | None\n</code></pre> <p>Get info about currently stored tiles.</p> <p>Returns:</p> <ul> <li> <code>GeoDataFrame | None</code>           \u2013            <p>gpd.GeoDataFrame: Tiles from odc.geo.GeoboxTiles. None if datacube is empty.</p> </li> </ul> Source code in <code>src/smart_geocubes/accessors/gee.py</code> <pre><code>def current_state(self) -&gt; gpd.GeoDataFrame | None:\n    \"\"\"Get info about currently stored tiles.\n\n    Returns:\n        gpd.GeoDataFrame: Tiles from odc.geo.GeoboxTiles. None if datacube is empty.\n\n    \"\"\"\n    import geopandas as gpd\n\n    if not self.created:\n        return None\n\n    session = self.repo.readonly_session(\"main\")\n    zcube = zarr.open(session.store, mode=\"r\")\n    loaded_tiles = zcube.attrs.get(\"loaded_tiles\", [])\n\n    if len(loaded_tiles) == 0:\n        return None\n\n    tiles = GeoboxTiles(self.extent, (self.chunk_size, self.chunk_size))\n    loaded_tiles = [{\"geometry\": tiles[_id_to_tileidx(tid)].extent.geom, \"id\": tid} for tid in loaded_tiles]\n    gdf = gpd.GeoDataFrame(loaded_tiles, crs=self.extent.crs.to_wkt())\n    return gdf\n</code></pre>"},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors.GEEAccessor.download_tile","title":"download_tile","text":"<pre><code>download_tile(zcube: Group, geobox_tile: TileWrapper)\n</code></pre> <p>Download a tile from Google Earth Engine.</p> <p>Parameters:</p> Source code in <code>src/smart_geocubes/accessors/gee.py</code> <pre><code>def download_tile(self, zcube: zarr.Group, geobox_tile: TileWrapper):\n    \"\"\"Download a tile from Google Earth Engine.\n\n    Args:\n        zcube (zarr.Group): The zarr datacube to download the tile to.\n        geobox_tile (TileWrapper): The tile to download.\n\n    \"\"\"\n    import ee\n    import rioxarray  # noqa: F401\n    import xee  # noqa: F401\n\n    # Note: This is a little bit weird: First we create an own grid which overlaps to the chunks\n    # of the zarr array. Then we create a mosaic of the data and clip it to a single chunk.\n    # We could load the images from the collection directly instead of creating a mosaic.\n    # However, this would require more testing and probably results a lot of manual computation\n    # of slices etc. like in the stac variant. So for now, we just use the mosaic.\n    logging.getLogger(\"urllib3.connectionpool\").disabled = True\n    geom = ee.Geometry.Rectangle(geobox_tile.item.geographic_extent.boundingbox)\n    ee_img = ee.ImageCollection(self.collection).mosaic().clip(geom)\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\"ignore\", category=UserWarning, message=EE_WARN_MSG)\n        tile = xr.open_dataset(\n            ee_img,\n            engine=\"ee\",\n            geometry=geom,\n            crs=f\"epsg:{self.extent.crs.to_epsg()}\",\n            scale=self.extent.resolution.x,\n        )\n\n    # TODO: Allow for multi-temporal datacubes and lat/lon coordinates\n    tile = tile.max(\"time\").rename({\"lon\": \"x\", \"lat\": \"y\"}).transpose(\"y\", \"x\")\n\n    # Download the data\n    tile.load()\n    logging.getLogger(\"urllib3.connectionpool\").disabled = False\n\n    # Flip y-axis, because convention is x in positive direction and y in negative, but gee use positive for both\n    tile = tile.isel(y=slice(None, None, -1))\n\n    # For some reason xee does not always set the crs\n    tile = tile.odc.assign_crs(self.extent.crs)\n\n    # Recrop the data to the geobox_tile, since gee does not always return the exact extent\n    tile = tile.odc.crop(geobox_tile.item.extent)\n\n    # Save original min-max values for each band for clipping later\n    clip_values = {\n        band: (tile[band].min().values.item(), tile[band].max().values.item()) for band in tile.data_vars\n    }\n\n    # Interpolate missing values (there are very few, so we actually can interpolate them)\n    tile.rio.set_spatial_dims(x_dim=\"x\", y_dim=\"y\", inplace=True)\n    for band in tile.data_vars:\n        tile[band] = tile[band].rio.write_nodata(np.nan).rio.interpolate_na()\n\n    # Convert to uint8\n    for band in tile.data_vars:\n        band_min, band_max = clip_values[band]\n        tile[band] = tile[band].clip(band_min, band_max, keep_attrs=True).astype(\"uint8\").rio.write_nodata(None)\n\n    # Get the slice of the datacube where the tile will be written\n    logger.debug(\n        f\"{geobox_tile.id=}: {tile.sizes=} {tile.x[0].item()=} {tile.y[0].item()=}\"\n        f\" {zcube['x'][0]=} {zcube['y'][0]=}\"\n    )\n    target_slice = self.zgeobox.overlap_roi(tile.odc.geobox)\n\n    logger.debug(f\"tile.id={geobox_tile.id}: Writing to {target_slice=}\")\n\n    for channel in self.channels:\n        raw_data = tile[channel].values\n        zcube[channel][target_slice] = raw_data\n</code></pre>"},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors.GEEAccessor.download_tile(zcube)","title":"<code>zcube</code>","text":"(<code>Group</code>)           \u2013            <p>The zarr datacube to download the tile to.</p>"},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors.GEEAccessor.download_tile(geobox_tile)","title":"<code>geobox_tile</code>","text":"(<code>TileWrapper</code>)           \u2013            <p>The tile to download.</p>"},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors.RemoteAccessor","title":"RemoteAccessor","text":"<pre><code>RemoteAccessor(\n    storage: Storage | Path | str,\n    create_icechunk_storage: bool = True,\n    title: str | None = None,\n    extent: GeoBox | None = None,\n    chunk_size: int | None = None,\n    channels: list | None = None,\n    channels_meta: dict | None = None,\n    channels_encoding: dict | None = None,\n)\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>Base class for remote accessors.</p> <p>Initialize base class for remote accessors.</p> <p>Warning</p> <p>In a multiprocessing environment, it is strongly recommended to not set <code>create_icechunk_storage=False</code>.</p> <p>The arguments <code>title</code>, <code>extent</code>, <code>chunk_size</code>, <code>channels</code>, <code>channels_meta</code> and <code>channels_encoding</code> will overwrite the dataset defaults and are only considered for the creation of a new datacube. It is strongly recommended to not set these values manually.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the storage is not an icechunk.Storage.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>adjacent_tiles</code>             \u2013              <p>Get the adjacent tiles for the given geobox.</p> </li> <li> <code>assert_created</code>             \u2013              <p>Assert that the datacube exists in the storage.</p> </li> <li> <code>create</code>             \u2013              <p>Create an empty datacube and write it to the store.</p> </li> <li> <code>current_state</code>             \u2013              <p>Get info about currently stored tiles / chunk.</p> </li> <li> <code>download_tile</code>             \u2013              <p>Download the data for the given tile.</p> </li> <li> <code>load</code>             \u2013              <p>Load the data for the given geobox.</p> </li> <li> <code>load_like</code>             \u2013              <p>Load the data for the given geobox.</p> </li> <li> <code>log_benchmark_summary</code>             \u2013              <p>Log the benchmark summary.</p> </li> <li> <code>open_xarray</code>             \u2013              <p>Open the xarray datacube in read-only mode.</p> </li> <li> <code>open_zarr</code>             \u2013              <p>Open the zarr datacube in read-only mode.</p> </li> <li> <code>post_create</code>             \u2013              <p>Post create actions. Can be overwritten by the dataset accessor.</p> </li> <li> <code>procedural_download</code>             \u2013              <p>Download the data for the given geobox.</p> </li> <li> <code>procedural_download_blocking</code>             \u2013              <p>Download tiles procedurally in blocking mode.</p> </li> <li> <code>procedural_download_threading</code>             \u2013              <p>Download tiles procedurally in threading mode.</p> </li> <li> <code>visualize_state</code>             \u2013              <p>Visulize currently stored tiles / chunk.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>created</code>               (<code>bool</code>)           \u2013            <p>Check if the datacube already exists in the storage.</p> </li> <li> <code>zgeobox</code>               (<code>GeoBox</code>)           \u2013            <p>Turn a zarr datacube into a GeoBox.</p> </li> </ul> Source code in <code>src/smart_geocubes/accessors/base.py</code> <pre><code>def __init__(\n    self,\n    storage: icechunk.Storage | Path | str,\n    create_icechunk_storage: bool = True,\n    title: str | None = None,\n    extent: GeoBox | None = None,\n    chunk_size: int | None = None,\n    channels: list | None = None,\n    channels_meta: dict | None = None,\n    channels_encoding: dict | None = None,\n):\n    \"\"\"Initialize base class for remote accessors.\n\n    !!! warning\n\n        In a multiprocessing environment, it is strongly recommended to not set `create_icechunk_storage=False`.\n\n    The arguments `title`, `extent`, `chunk_size`, `channels`, `channels_meta` and `channels_encoding`\n    will overwrite the dataset defaults and are only considered for the creation of a new datacube.\n    It is strongly recommended to not set these values manually.\n\n    Args:\n        storage (icechunk.Storage): The icechunk storage of the datacube.\n        create_icechunk_storage (bool, optional): If an icechunk repository should be created at provided storage\n            if no exists.\n            This should be disabled in a multiprocessing environment.\n            Defaults to True.\n        title (str | None, optional): The title of the datacube. Defaults to None.\n        extent (GeoBox | None, optional): The extent of the datacube. Defaults to None.\n        chunk_size (int | None, optional): The chunk size of the datacube. Defaults to None.\n        channels (list | None, optional): The channels of the datacube. Defaults to None.\n        channels_meta (dict | None, optional): The channels meta of the datacube. Defaults to None.\n        channels_encoding (dict | None, optional): The channels encoding of the datacube. Defaults to None.\n\n    Raises:\n        ValueError: If the storage is not an icechunk.Storage.\n\n    \"\"\"\n    if isinstance(storage, (str | Path)):\n        storage = storage if isinstance(storage, str) else str(storage.resolve())\n        storage = icechunk.local_filesystem_storage(storage)\n    if not isinstance(storage, icechunk.Storage):\n        raise ValueError(f\"Expected an icechunk.Storage, but got {type(storage)}\")\n    self.storage = storage\n    logger.debug(f\"Using storage {storage=}\")\n    if create_icechunk_storage:\n        self.repo = icechunk.Repository.open_or_create(storage)  # Will create a \"main\" branch\n    else:\n        self.repo = icechunk.Repository.open(storage)\n    logger.debug(f\"Using repository {self.repo=}\")\n\n    # We overwrite optionally the dataset attributes with user defined settings\n    self.title = title or type(self).__name__\n    if extent is not None:\n        self.extent = extent\n    if chunk_size is not None:\n        self.chunk_size = chunk_size\n    if channels is not None:\n        self.channels = channels\n    if channels_meta is not None:\n        self.channels_meta\n    if channels_encoding is not None:\n        self.channels_encoding\n\n    # TODO: store the settings variables in metadata and validate here\n\n    # The benchmarking timer for this accessor\n    self.stopuhr = StopUhr(logger.debug)\n\n    # The TypeVar used by the ThreadingHandler was added in 3.12\n    # The Shutdown method of the queue was added in 3.13\n    # Hence, we don't want to import the module unless Python 3.13 is installed\n    if _check_python_version(3, 13):\n        from smart_geocubes.concurrency.threading import ThreadingHandler\n\n        self.threading_handler = ThreadingHandler(self._threading_download)\n</code></pre>"},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors.RemoteAccessor(storage)","title":"<code>storage</code>","text":"(<code>Storage</code>)           \u2013            <p>The icechunk storage of the datacube.</p>"},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors.RemoteAccessor(create_icechunk_storage)","title":"<code>create_icechunk_storage</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If an icechunk repository should be created at provided storage if no exists. This should be disabled in a multiprocessing environment. Defaults to True.</p>"},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors.RemoteAccessor(title)","title":"<code>title</code>","text":"(<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The title of the datacube. Defaults to None.</p>"},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors.RemoteAccessor(extent)","title":"<code>extent</code>","text":"(<code>GeoBox | None</code>, default:                   <code>None</code> )           \u2013            <p>The extent of the datacube. Defaults to None.</p>"},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors.RemoteAccessor(chunk_size)","title":"<code>chunk_size</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The chunk size of the datacube. Defaults to None.</p>"},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors.RemoteAccessor(channels)","title":"<code>channels</code>","text":"(<code>list | None</code>, default:                   <code>None</code> )           \u2013            <p>The channels of the datacube. Defaults to None.</p>"},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors.RemoteAccessor(channels_meta)","title":"<code>channels_meta</code>","text":"(<code>dict | None</code>, default:                   <code>None</code> )           \u2013            <p>The channels meta of the datacube. Defaults to None.</p>"},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors.RemoteAccessor(channels_encoding)","title":"<code>channels_encoding</code>","text":"(<code>dict | None</code>, default:                   <code>None</code> )           \u2013            <p>The channels encoding of the datacube. Defaults to None.</p>"},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors.RemoteAccessor.created","title":"created  <code>property</code>","text":"<pre><code>created: bool\n</code></pre> <p>Check if the datacube already exists in the storage.</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if the datacube already exists in the storage.</p> </li> </ul>"},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors.RemoteAccessor.zgeobox","title":"zgeobox  <code>cached</code> <code>property</code>","text":"<pre><code>zgeobox: GeoBox\n</code></pre> <p>Turn a zarr datacube into a GeoBox.</p> <p>This SHOULD be equal to the .extent geobox. However, this property is used to find the target index of the downloaded data, so better save than sorry.</p> <p>Returns:</p> <ul> <li> <code>GeoBox</code> (              <code>GeoBox</code> )          \u2013            <p>The GeoBox created from the zarr datacube.</p> </li> </ul>"},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors.RemoteAccessor.adjacent_tiles","title":"adjacent_tiles  <code>abstractmethod</code>","text":"<pre><code>adjacent_tiles(geobox: GeoBox) -&gt; list[TileWrapper]\n</code></pre> <p>Get the adjacent tiles for the given geobox.</p> <p>Must be implemented by the Accessor.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[TileWrapper]</code>           \u2013            <p>list[TileWrapper]: The adjacent tile(-id)s for the given geobox.</p> </li> </ul> Source code in <code>src/smart_geocubes/accessors/base.py</code> <pre><code>@abstractmethod\ndef adjacent_tiles(self, geobox: GeoBox) -&gt; list[TileWrapper]:\n    \"\"\"Get the adjacent tiles for the given geobox.\n\n    Must be implemented by the Accessor.\n\n    Args:\n        geobox (GeoBox): The reference geobox to get the adjacent tiles for.\n\n    Returns:\n        list[TileWrapper]: The adjacent tile(-id)s for the given geobox.\n\n    \"\"\"\n</code></pre>"},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors.RemoteAccessor.adjacent_tiles(geobox)","title":"<code>geobox</code>","text":"(<code>GeoBox</code>)           \u2013            <p>The reference geobox to get the adjacent tiles for.</p>"},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors.RemoteAccessor.assert_created","title":"assert_created","text":"<pre><code>assert_created()\n</code></pre> <p>Assert that the datacube exists in the storage.</p> <p>Raises:</p> <ul> <li> <code>FileNotFoundError</code>             \u2013            <p>If the datacube does not exist.</p> </li> </ul> Source code in <code>src/smart_geocubes/accessors/base.py</code> <pre><code>def assert_created(self):\n    \"\"\"Assert that the datacube exists in the storage.\n\n    Raises:\n        FileNotFoundError: If the datacube does not exist.\n\n    \"\"\"\n    if not self.created:\n        msg = f\"Datacube {self.title} does not exist.\"\n        \" Please use the `create` method or pass `create=True` to `load`.\"\n        logger.error(msg)\n        raise FileNotFoundError(msg)\n</code></pre>"},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors.RemoteAccessor.create","title":"create","text":"<pre><code>create(overwrite: bool = False)\n</code></pre> <p>Create an empty datacube and write it to the store.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>FileExistsError</code>             \u2013            <p>If a datacube already exists at location</p> </li> </ul> Source code in <code>src/smart_geocubes/accessors/base.py</code> <pre><code>def create(self, overwrite: bool = False):\n    \"\"\"Create an empty datacube and write it to the store.\n\n    Args:\n        overwrite (bool, optional): Allowing overwriting an existing datacube. Defaults to False.\n\n    Raises:\n        FileExistsError: If a datacube already exists at location\n\n    \"\"\"\n    with self.stopuhr(\"Empty datacube creation\"):\n        # Check if the zarr data already exists\n        session = self.repo.writable_session(\"main\")\n        cube_is_empty = sync(session.store.is_empty(\"\"))\n        if not overwrite and not cube_is_empty:\n            logger.debug(f\"Unable to create a new datacube. {overwrite=} {cube_is_empty=} {session.store=}\")\n            raise FileExistsError(f\"Cannot create a new  datacube. {session.store=} is not empty!\")\n\n        logger.debug(\n            f\"Creating an empty zarr datacube '{self.title}' with the variables\"\n            f\" {self.channels} at a {self.extent.resolution=} (epsg:{self.extent.crs.epsg})\"\n            f\" and {self.chunk_size=} to {session.store=}\"\n        )\n\n        ds = xr.Dataset(\n            {\n                name: odc.geo.xr.xr_zeros(\n                    self.extent,\n                    chunks=-1,\n                    dtype=self.channels_encoding[name].get(\"dtype\", \"float32\"),\n                    always_yx=True,\n                )\n                for name in self.channels\n            },\n            attrs={\"title\": self.title, \"loaded_tiles\": []},\n        )\n\n        # Add metadata\n        for name, meta in self.channels_meta.items():\n            ds[name].attrs.update(meta)\n\n        # Get the encoding for the coordinates, variables and spatial reference\n        coords_encoding = {\n            \"x\": {\"chunks\": ds.x.shape, **optimize_coord_encoding(ds.x.values, self.extent.resolution.x)},\n            \"y\": {\"chunks\": ds.y.shape, **optimize_coord_encoding(ds.y.values, self.extent.resolution.y)},\n        }\n        var_encoding = {\n            name: {\n                \"chunks\": (self.chunk_size, self.chunk_size),\n                \"compressors\": [BloscCodec(clevel=9)],\n                **self.channels_encoding[name],\n            }\n            for name in self.channels\n        }\n        encoding = {\n            \"spatial_ref\": {\"chunks\": None, \"dtype\": \"int32\"},\n            **coords_encoding,\n            **var_encoding,\n        }\n        logger.debug(f\"Datacube {encoding=}\")\n\n        ds.to_zarr(\n            session.store,\n            encoding=encoding,\n            compute=False,\n            consolidated=False,\n            zarr_format=3,\n            mode=\"w\" if overwrite else \"w-\",\n        )\n\n        commit = session.commit(\"Initialize empty datacube\")\n        logger.debug(f\"Datacube created: {commit=}\")\n\n        self.post_create()\n</code></pre>"},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors.RemoteAccessor.create(overwrite)","title":"<code>overwrite</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Allowing overwriting an existing datacube. Defaults to False.</p>"},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors.RemoteAccessor.current_state","title":"current_state  <code>abstractmethod</code>","text":"<pre><code>current_state() -&gt; gpd.GeoDataFrame | None\n</code></pre> <p>Get info about currently stored tiles / chunk.</p> <p>Must be implemented by the Accessor.</p> <p>Returns:</p> <ul> <li> <code>GeoDataFrame | None</code>           \u2013            <p>gpd.GeoDataFrame | None: Tile or Chunk info.</p> </li> </ul> Source code in <code>src/smart_geocubes/accessors/base.py</code> <pre><code>@abstractmethod\ndef current_state(self) -&gt; gpd.GeoDataFrame | None:\n    \"\"\"Get info about currently stored tiles / chunk.\n\n    Must be implemented by the Accessor.\n\n    Returns:\n        gpd.GeoDataFrame | None: Tile or Chunk info.\n\n    \"\"\"\n</code></pre>"},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors.RemoteAccessor.download_tile","title":"download_tile  <code>abstractmethod</code>","text":"<pre><code>download_tile(zcube: Array, tile: TileWrapper)\n</code></pre> <p>Download the data for the given tile.</p> <p>Must be implemented by the Accessor.</p> <p>Parameters:</p> Source code in <code>src/smart_geocubes/accessors/base.py</code> <pre><code>@abstractmethod\ndef download_tile(self, zcube: zarr.Array, tile: TileWrapper):\n    \"\"\"Download the data for the given tile.\n\n    Must be implemented by the Accessor.\n\n    Args:\n        zcube (zarr.Array): The datacube to write the tile data to.\n        tile (TileWrapper): The reference tile to download the data for.\n\n    \"\"\"\n</code></pre>"},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors.RemoteAccessor.download_tile(zcube)","title":"<code>zcube</code>","text":"(<code>Array</code>)           \u2013            <p>The datacube to write the tile data to.</p>"},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors.RemoteAccessor.download_tile(tile)","title":"<code>tile</code>","text":"(<code>TileWrapper</code>)           \u2013            <p>The reference tile to download the data for.</p>"},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors.RemoteAccessor.load","title":"load","text":"<pre><code>load(\n    geobox: GeoBox,\n    buffer: int = 0,\n    persist: bool = True,\n    create: bool = False,\n    concurrency_mode: ConcurrencyModes = \"blocking\",\n) -&gt; xr.Dataset\n</code></pre> <p>Load the data for the given geobox.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Dataset</code>           \u2013            <p>xr.Dataset: The loaded dataset in the same resolution and extent like the geobox.</p> </li> </ul> Source code in <code>src/smart_geocubes/accessors/base.py</code> <pre><code>def load(\n    self,\n    geobox: GeoBox,\n    buffer: int = 0,\n    persist: bool = True,\n    create: bool = False,\n    concurrency_mode: ConcurrencyModes = \"blocking\",\n) -&gt; xr.Dataset:\n    \"\"\"Load the data for the given geobox.\n\n    Args:\n        geobox (GeoBox): The reference geobox to load the data for.\n        buffer (int, optional): The buffer around the projected geobox in pixels. Defaults to 0.\n        persist (bool, optional): If the data should be persisted in memory.\n            If not, this will return a Dask backed Dataset. Defaults to True.\n        create (bool, optional): Create a new zarr array at defined storage if it not exists.\n            This is not recommended, because it can have side effects in a multi-process environment.\n            Defaults to False.\n        concurrency_mode (ConcurrencyModes, optional): The concurrency mode for the download.\n            Defaults to \"blocking\".\n\n    Returns:\n        xr.Dataset: The loaded dataset in the same resolution and extent like the geobox.\n\n    \"\"\"\n    with self.stopuhr(f\"{geobox=}: {self.title} tile {'loading' if persist else 'lazy-loading'}\"):\n        logger.debug(f\"{geobox=}: {geobox.resolution.x}m original resolution\")\n\n        # Create the datacube if it does not exist\n        if create:\n            try:\n                self.create(overwrite=False)\n            except FileExistsError:  # We are okay if the datacube already exists\n                pass\n        else:\n            # Check if the datacube exists\n            self.assert_created()\n\n        # Download the adjacent tiles (if necessary)\n        reference_geobox = geobox.to_crs(self.extent.crs, resolution=self.extent.resolution.x).pad(buffer)\n        self.procedural_download(reference_geobox, concurrency_mode=concurrency_mode)\n\n        # Load the datacube and set the spatial_ref since it is set as a coordinate within the zarr format\n        session = self.repo.readonly_session(\"main\")\n        chunks = None if persist else \"auto\"\n        xrcube = xr.open_zarr(\n            session.store,\n            mask_and_scale=False,\n            chunks=chunks,\n            consolidated=False,\n        ).set_coords(\"spatial_ref\")\n\n        # Get an AOI slice of the datacube\n        xrcube_aoi = xrcube.odc.crop(reference_geobox.extent, apply_mask=False)\n\n        # The following code would load the lazy zarr data from disk into memory\n        if persist:\n            with self.stopuhr(f\"{geobox=}: {self.title} AOI loading from disk\"):\n                xrcube_aoi = xrcube_aoi.load()\n    return xrcube_aoi\n</code></pre>"},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors.RemoteAccessor.load(geobox)","title":"<code>geobox</code>","text":"(<code>GeoBox</code>)           \u2013            <p>The reference geobox to load the data for.</p>"},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors.RemoteAccessor.load(buffer)","title":"<code>buffer</code>","text":"(<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The buffer around the projected geobox in pixels. Defaults to 0.</p>"},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors.RemoteAccessor.load(persist)","title":"<code>persist</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If the data should be persisted in memory. If not, this will return a Dask backed Dataset. Defaults to True.</p>"},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors.RemoteAccessor.load(create)","title":"<code>create</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Create a new zarr array at defined storage if it not exists. This is not recommended, because it can have side effects in a multi-process environment. Defaults to False.</p>"},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors.RemoteAccessor.load(concurrency_mode)","title":"<code>concurrency_mode</code>","text":"(<code>ConcurrencyModes</code>, default:                   <code>'blocking'</code> )           \u2013            <p>The concurrency mode for the download. Defaults to \"blocking\".</p>"},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors.RemoteAccessor.load_like","title":"load_like","text":"<pre><code>load_like(\n    ref: Dataset | DataArray, **kwargs: Unpack[LoadParams]\n) -&gt; xr.Dataset\n</code></pre> <p>Load the data for the given geobox.</p> <p>Parameters:</p> <p>Other Parameters:</p> <ul> <li> <code>buffer</code>               (<code>int</code>)           \u2013            <p>The buffer around the projected geobox in pixels. Defaults to 0.</p> </li> <li> <code>persist</code>               (<code>bool</code>)           \u2013            <p>If the data should be persisted in memory. If not, this will return a Dask backed Dataset. Defaults to True.</p> </li> <li> <code>create</code>               (<code>bool</code>)           \u2013            <p>Create a new zarr array at defined storage if it not exists. This is not recommended, because it can have side effects in a multi-process environment. Defaults to False.</p> </li> <li> <code>concurrency_mode</code>               (<code>ConcurrencyModes</code>)           \u2013            <p>The concurrency mode for the download. Defaults to \"blocking\".</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dataset</code>           \u2013            <p>xr.Dataset: The loaded dataset in the same resolution and extent like the geobox.</p> </li> </ul> Source code in <code>src/smart_geocubes/accessors/base.py</code> <pre><code>def load_like(\n    self,\n    ref: xr.Dataset | xr.DataArray,\n    **kwargs: Unpack[LoadParams],\n) -&gt; xr.Dataset:\n    \"\"\"Load the data for the given geobox.\n\n    Args:\n        ref (xr.Dataset | xr.DataArray): The reference dataarray or dataset to load the data for.\n        **kwargs: The load parameters (buffer, persist, create, concurrency_mode).\n\n    Keyword Args:\n        buffer (int, optional): The buffer around the projected geobox in pixels. Defaults to 0.\n        persist (bool, optional): If the data should be persisted in memory.\n            If not, this will return a Dask backed Dataset. Defaults to True.\n        create (bool, optional): Create a new zarr array at defined storage if it not exists.\n            This is not recommended, because it can have side effects in a multi-process environment.\n            Defaults to False.\n        concurrency_mode (ConcurrencyModes, optional): The concurrency mode for the download.\n            Defaults to \"blocking\".\n\n    Returns:\n        xr.Dataset: The loaded dataset in the same resolution and extent like the geobox.\n\n    \"\"\"\n    return self.load(geobox=ref.geobox, **kwargs)\n</code></pre>"},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors.RemoteAccessor.load_like(ref)","title":"<code>ref</code>","text":"(<code>Dataset | DataArray</code>)           \u2013            <p>The reference dataarray or dataset to load the data for.</p>"},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors.RemoteAccessor.load_like(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Unpack[LoadParams]</code>, default:                   <code>{}</code> )           \u2013            <p>The load parameters (buffer, persist, create, concurrency_mode).</p>"},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors.RemoteAccessor.log_benchmark_summary","title":"log_benchmark_summary","text":"<pre><code>log_benchmark_summary()\n</code></pre> <p>Log the benchmark summary.</p> Source code in <code>src/smart_geocubes/accessors/base.py</code> <pre><code>def log_benchmark_summary(self):\n    \"\"\"Log the benchmark summary.\"\"\"\n    self.stopuhr.summary()\n</code></pre>"},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors.RemoteAccessor.open_xarray","title":"open_xarray","text":"<pre><code>open_xarray() -&gt; xr.Dataset\n</code></pre> <p>Open the xarray datacube in read-only mode.</p> <p>Returns:</p> <ul> <li> <code>Dataset</code>           \u2013            <p>xr.Dataset: The xarray datacube.</p> </li> </ul> Source code in <code>src/smart_geocubes/accessors/base.py</code> <pre><code>def open_xarray(self) -&gt; xr.Dataset:\n    \"\"\"Open the xarray datacube in read-only mode.\n\n    Returns:\n        xr.Dataset: The xarray datacube.\n\n    \"\"\"\n    self.assert_created()\n    session = self.repo.readonly_session(\"main\")\n    xcube = xr.open_zarr(session.store, mask_and_scale=False, consolidated=False).set_coords(\"spatial_ref\")\n    return xcube\n</code></pre>"},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors.RemoteAccessor.open_zarr","title":"open_zarr","text":"<pre><code>open_zarr() -&gt; zarr.Group\n</code></pre> <p>Open the zarr datacube in read-only mode.</p> <p>Returns:</p> <ul> <li> <code>Group</code>           \u2013            <p>zarr.Group: The zarr datacube.</p> </li> </ul> Source code in <code>src/smart_geocubes/accessors/base.py</code> <pre><code>def open_zarr(self) -&gt; zarr.Group:\n    \"\"\"Open the zarr datacube in read-only mode.\n\n    Returns:\n        zarr.Group: The zarr datacube.\n\n    \"\"\"\n    self.assert_created()\n    session = self.repo.readonly_session(\"main\")\n    zcube = zarr.open(store=session.store, mode=\"r\")\n    return zcube\n</code></pre>"},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors.RemoteAccessor.post_create","title":"post_create","text":"<pre><code>post_create()\n</code></pre> <p>Post create actions. Can be overwritten by the dataset accessor.</p> Source code in <code>src/smart_geocubes/accessors/base.py</code> <pre><code>def post_create(self):\n    \"\"\"Post create actions. Can be overwritten by the dataset accessor.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors.RemoteAccessor.procedural_download","title":"procedural_download","text":"<pre><code>procedural_download(\n    geobox: GeoBox,\n    concurrency_mode: ConcurrencyModes = \"blocking\",\n)\n</code></pre> <p>Download the data for the given geobox.</p> Note <p>The \"threading\" concurrency mode requires Python 3.13 or higher.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If an unknown concurrency mode is provided.</p> </li> </ul> Source code in <code>src/smart_geocubes/accessors/base.py</code> <pre><code>def procedural_download(self, geobox: GeoBox, concurrency_mode: ConcurrencyModes = \"blocking\"):\n    \"\"\"Download the data for the given geobox.\n\n    Note:\n        The \"threading\" concurrency mode requires Python 3.13 or higher.\n\n    Args:\n        geobox (GeoBox): The reference geobox to download the data for.\n        concurrency_mode (ConcurrencyModes, optional): The concurrency mode for the download.\n            Defaults to \"blocking\".\n\n    Raises:\n        ValueError: If an unknown concurrency mode is provided.\n\n    \"\"\"\n    self.assert_created()\n    if concurrency_mode == \"blocking\":\n        self.procedural_download_blocking(geobox)\n    elif concurrency_mode == \"threading\":\n        self.procedural_download_threading(geobox)\n    else:\n        raise ValueError(f\"Unknown concurrency mode {concurrency_mode}\")\n</code></pre>"},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors.RemoteAccessor.procedural_download(geobox)","title":"<code>geobox</code>","text":"(<code>GeoBox</code>)           \u2013            <p>The reference geobox to download the data for.</p>"},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors.RemoteAccessor.procedural_download(concurrency_mode)","title":"<code>concurrency_mode</code>","text":"(<code>ConcurrencyModes</code>, default:                   <code>'blocking'</code> )           \u2013            <p>The concurrency mode for the download. Defaults to \"blocking\".</p>"},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors.RemoteAccessor.procedural_download_blocking","title":"procedural_download_blocking","text":"<pre><code>procedural_download_blocking(\n    geobox: GeoBox, tries: int = 5\n)\n</code></pre> <p>Download tiles procedurally in blocking mode.</p> Warning <p>This method is meant for single-process use, but can (in theory) be used in a multi-process environment. However, in a multi-process environment it can happen that multiple processes try to write concurrently, which results in a conflict. In such cases, the download will be retried until it succeeds or the number of maximum-tries is reached.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If no adjacent tiles are found. This can happen if the geobox is out of the dataset bounds.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If no tries are left.</p> </li> </ul> Source code in <code>src/smart_geocubes/accessors/base.py</code> <pre><code>def procedural_download_blocking(self, geobox: GeoBox, tries: int = 5):\n    \"\"\"Download tiles procedurally in blocking mode.\n\n    Warning:\n        This method is meant for single-process use, but can (in theory) be used in a multi-process environment.\n        However, in a multi-process environment it can happen that multiple processes try to write concurrently,\n        which results in a conflict.\n        In such cases, the download will be retried until it succeeds or the number of maximum-tries is reached.\n\n    Args:\n        geobox (GeoBox): The geobox of the aoi to download.\n        tries (int, optional): Number of maximum tries. Defaults to 5.\n\n    Raises:\n        ValueError: If no adjacent tiles are found. This can happen if the geobox is out of the dataset bounds.\n        ValueError: If no tries are left.\n\n    \"\"\"\n    if tries == 0:\n        logger.warning(\"No tries left, skipping download\")\n        raise ValueError(\"Unable to commit, no tries left.\")\n\n    with self.stopuhr(f\"{geobox=}: Procedural download in blocking mode\"):\n        adjacent_tiles = self.adjacent_tiles(geobox)\n        if not adjacent_tiles:\n            logger.error(f\"{geobox=}: No adjacent tiles found: {adjacent_tiles=}\")\n            raise ValueError(\"No adjacent tiles found - is the provided geobox corrent?\")\n\n        session = self.repo.writable_session(\"main\")\n        zcube = zarr.open(store=session.store, mode=\"r+\")\n        loaded_tiles = zcube.attrs.get(\"loaded_tiles\", [])\n        new_tiles = [tile for tile in adjacent_tiles if tile.id not in loaded_tiles]\n        logger.debug(f\"{geobox=}:  {len(adjacent_tiles)=} &amp; {len(loaded_tiles)=} -&gt; {len(new_tiles)=} to download\")\n        if not new_tiles:\n            return\n\n        for tile in new_tiles:\n            with self.stopuhr(f\"{tile.id=}: Downloading one new tile in blocking mode\"):\n                logger.debug(f\"{tile.id=}: Start downloading\")\n                self.download_tile(zcube, tile)\n\n            loaded_tiles.append(tile.id)\n            zcube.attrs[\"loaded_tiles\"] = loaded_tiles\n\n        try:\n            # session.rebase(icechunk.ConflictDetector())\n            session.commit(f\"Procedurally downloaded tiles {[tile.id for tile in new_tiles]} in blocking mode\")\n        # Currently not possible, because attrs will always result in a conflict\n        # except icechunk.RebaseFailedError as e:\n        #     logger.warning(f\"Rebase failed: {e}\")\n        #     logger.debug(f\"Retrying download with {tries - 1} tries left\")\n        #     self.procedural_download_blocking(geobox, tries=tries - 1)\n        except icechunk.ConflictError as e:\n            logger.warning(f\"Icechunk session is out of sync: {e}\")\n            logger.debug(f\"Retrying download with {tries - 1} tries left\")\n            self.procedural_download_blocking(geobox, tries=tries - 1)\n</code></pre>"},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors.RemoteAccessor.procedural_download_blocking(geobox)","title":"<code>geobox</code>","text":"(<code>GeoBox</code>)           \u2013            <p>The geobox of the aoi to download.</p>"},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors.RemoteAccessor.procedural_download_blocking(tries)","title":"<code>tries</code>","text":"(<code>int</code>, default:                   <code>5</code> )           \u2013            <p>Number of maximum tries. Defaults to 5.</p>"},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors.RemoteAccessor.procedural_download_threading","title":"procedural_download_threading","text":"<pre><code>procedural_download_threading(geobox: GeoBox)\n</code></pre> <p>Download tiles procedurally in threading mode.</p> Note <p>This method ensures that only a single download is running at a time. It uses a SetQueue to prevent duplicate downloads. The threading mode requires Python 3.13 or higher.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If no adjacent tiles are found. This can happen if the geobox is out of the dataset bounds.</p> </li> <li> <code>RuntimeError</code>             \u2013            <p>If the Python version is lower than 3.13.</p> </li> </ul> Source code in <code>src/smart_geocubes/accessors/base.py</code> <pre><code>def procedural_download_threading(self, geobox: GeoBox):\n    \"\"\"Download tiles procedurally in threading mode.\n\n    Note:\n        This method ensures that only a single download is running at a time.\n        It uses a SetQueue to prevent duplicate downloads.\n        The threading mode requires Python 3.13 or higher.\n\n    Args:\n        geobox (GeoBox): The geobox of the aoi to download.\n\n    Raises:\n        ValueError: If no adjacent tiles are found. This can happen if the geobox is out of the dataset bounds.\n        RuntimeError: If the Python version is lower than 3.13.\n\n    \"\"\"\n    if not _check_python_version(3, 13):\n        raise RuntimeError(\"Threading mode requires Python 3.13 or higher\")\n    with self.threading_handler:\n        adjacent_tiles = self.adjacent_tiles(geobox)\n        if not adjacent_tiles:\n            logger.error(f\"{geobox=}: No adjacent tiles found: {adjacent_tiles=}\")\n            raise ValueError(\"No adjacent tiles found - is the provided geobox corrent?\")\n\n        # Wait until all new_items are loaded\n        prev_len = None\n        while True:\n            session = self.repo.readonly_session(\"main\")\n            zcube = zarr.open(store=session.store, mode=\"r\")\n            loaded_tiles = zcube.attrs.get(\"loaded_tiles\", [])\n            new_tiles = [tile for tile in adjacent_tiles if tile.id not in loaded_tiles]\n            done_tiles = [tile for tile in adjacent_tiles if tile.id in loaded_tiles]\n            if not new_tiles:\n                break\n            if prev_len != len(new_tiles):\n                logger.debug(\n                    f\"{geobox=}: {len(done_tiles)} of {len(adjacent_tiles)} downloaded.\"\n                    f\" Missing: {[t.id for t in new_tiles]} Done: {[t.id for t in done_tiles]}\"\n                )\n            for tile in new_tiles:\n                self.threading_handler._queue.put(tile)\n            prev_len = len(new_tiles)\n            time.sleep(5)\n</code></pre>"},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors.RemoteAccessor.procedural_download_threading(geobox)","title":"<code>geobox</code>","text":"(<code>GeoBox</code>)           \u2013            <p>The geobox of the aoi to download.</p>"},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors.RemoteAccessor.visualize_state","title":"visualize_state  <code>abstractmethod</code>","text":"<pre><code>visualize_state(\n    ax: Axes | None = None,\n) -&gt; plt.Figure | plt.Axes\n</code></pre> <p>Visulize currently stored tiles / chunk.</p> <p>Must be implemented by the DatasetAccessor.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Figure | Axes</code>           \u2013            <p>plt.Figure | plt.Axes: The figure with the visualization</p> </li> </ul> Source code in <code>src/smart_geocubes/accessors/base.py</code> <pre><code>@abstractmethod\ndef visualize_state(self, ax: \"plt.Axes | None\" = None) -&gt; \"plt.Figure | plt.Axes\":\n    \"\"\"Visulize currently stored tiles / chunk.\n\n    Must be implemented by the DatasetAccessor.\n\n    Args:\n        ax (plt.Axes | None, optional): The axes drawn to. If None, will create a new figure and axes.\n            Defaults to None.\n\n    Returns:\n        plt.Figure | plt.Axes: The figure with the visualization\n\n    \"\"\"\n</code></pre>"},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors.RemoteAccessor.visualize_state(ax)","title":"<code>ax</code>","text":"(<code>Axes | None</code>, default:                   <code>None</code> )           \u2013            <p>The axes drawn to. If None, will create a new figure and axes. Defaults to None.</p>"},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors.STACAccessor","title":"STACAccessor","text":"<pre><code>STACAccessor(\n    storage: Storage | Path | str,\n    create_icechunk_storage: bool = True,\n    title: str | None = None,\n    extent: GeoBox | None = None,\n    chunk_size: int | None = None,\n    channels: list | None = None,\n    channels_meta: dict | None = None,\n    channels_encoding: dict | None = None,\n)\n</code></pre> <p>               Bases: <code>RemoteAccessor</code></p> <p>Accessor for STAC data.</p> <p>Methods:</p> <ul> <li> <code>adjacent_tiles</code>             \u2013              <p>Get adjacent tiles from a STAC API.</p> </li> <li> <code>current_state</code>             \u2013              <p>Get info about currently stored tiles.</p> </li> <li> <code>download_tile</code>             \u2013              <p>Download a tile from a STAC API and write it to a zarr datacube.</p> </li> </ul> Source code in <code>src/smart_geocubes/accessors/base.py</code> <pre><code>def __init__(\n    self,\n    storage: icechunk.Storage | Path | str,\n    create_icechunk_storage: bool = True,\n    title: str | None = None,\n    extent: GeoBox | None = None,\n    chunk_size: int | None = None,\n    channels: list | None = None,\n    channels_meta: dict | None = None,\n    channels_encoding: dict | None = None,\n):\n    \"\"\"Initialize base class for remote accessors.\n\n    !!! warning\n\n        In a multiprocessing environment, it is strongly recommended to not set `create_icechunk_storage=False`.\n\n    The arguments `title`, `extent`, `chunk_size`, `channels`, `channels_meta` and `channels_encoding`\n    will overwrite the dataset defaults and are only considered for the creation of a new datacube.\n    It is strongly recommended to not set these values manually.\n\n    Args:\n        storage (icechunk.Storage): The icechunk storage of the datacube.\n        create_icechunk_storage (bool, optional): If an icechunk repository should be created at provided storage\n            if no exists.\n            This should be disabled in a multiprocessing environment.\n            Defaults to True.\n        title (str | None, optional): The title of the datacube. Defaults to None.\n        extent (GeoBox | None, optional): The extent of the datacube. Defaults to None.\n        chunk_size (int | None, optional): The chunk size of the datacube. Defaults to None.\n        channels (list | None, optional): The channels of the datacube. Defaults to None.\n        channels_meta (dict | None, optional): The channels meta of the datacube. Defaults to None.\n        channels_encoding (dict | None, optional): The channels encoding of the datacube. Defaults to None.\n\n    Raises:\n        ValueError: If the storage is not an icechunk.Storage.\n\n    \"\"\"\n    if isinstance(storage, (str | Path)):\n        storage = storage if isinstance(storage, str) else str(storage.resolve())\n        storage = icechunk.local_filesystem_storage(storage)\n    if not isinstance(storage, icechunk.Storage):\n        raise ValueError(f\"Expected an icechunk.Storage, but got {type(storage)}\")\n    self.storage = storage\n    logger.debug(f\"Using storage {storage=}\")\n    if create_icechunk_storage:\n        self.repo = icechunk.Repository.open_or_create(storage)  # Will create a \"main\" branch\n    else:\n        self.repo = icechunk.Repository.open(storage)\n    logger.debug(f\"Using repository {self.repo=}\")\n\n    # We overwrite optionally the dataset attributes with user defined settings\n    self.title = title or type(self).__name__\n    if extent is not None:\n        self.extent = extent\n    if chunk_size is not None:\n        self.chunk_size = chunk_size\n    if channels is not None:\n        self.channels = channels\n    if channels_meta is not None:\n        self.channels_meta\n    if channels_encoding is not None:\n        self.channels_encoding\n\n    # TODO: store the settings variables in metadata and validate here\n\n    # The benchmarking timer for this accessor\n    self.stopuhr = StopUhr(logger.debug)\n\n    # The TypeVar used by the ThreadingHandler was added in 3.12\n    # The Shutdown method of the queue was added in 3.13\n    # Hence, we don't want to import the module unless Python 3.13 is installed\n    if _check_python_version(3, 13):\n        from smart_geocubes.concurrency.threading import ThreadingHandler\n\n        self.threading_handler = ThreadingHandler(self._threading_download)\n</code></pre>"},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors.STACAccessor.adjacent_tiles","title":"adjacent_tiles","text":"<pre><code>adjacent_tiles(geobox: GeoBox) -&gt; list[TileWrapper]\n</code></pre> <p>Get adjacent tiles from a STAC API.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[TileWrapper]</code>           \u2013            <p>list[TileWrapper]: List of adjacent tiles, wrapped in own datastructure for easier processing.</p> </li> </ul> Source code in <code>src/smart_geocubes/accessors/stac.py</code> <pre><code>def adjacent_tiles(self, geobox: GeoBox) -&gt; list[TileWrapper]:\n    \"\"\"Get adjacent tiles from a STAC API.\n\n    Args:\n        geobox (GeoBox): The geobox for which to get adjacent tiles.\n\n    Returns:\n        list[TileWrapper]: List of adjacent tiles, wrapped in own datastructure for easier processing.\n\n    \"\"\"\n    import pystac_client\n\n    catalog = pystac_client.Client.open(self.stac_api_url)\n    search = catalog.search(collections=[self.collection], intersects=geobox.to_crs(\"EPSG:4326\").extent.geom)\n    items = list(search.items())\n    return [TileWrapper(item.id, item) for item in items]\n</code></pre>"},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors.STACAccessor.adjacent_tiles(geobox)","title":"<code>geobox</code>","text":"(<code>GeoBox</code>)           \u2013            <p>The geobox for which to get adjacent tiles.</p>"},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors.STACAccessor.current_state","title":"current_state","text":"<pre><code>current_state() -&gt; gpd.GeoDataFrame | None\n</code></pre> <p>Get info about currently stored tiles.</p> <p>Returns:</p> <ul> <li> <code>GeoDataFrame | None</code>           \u2013            <p>gpd.GeoDataFrame: Tile info from pystac. None if datacube is empty.</p> </li> </ul> Source code in <code>src/smart_geocubes/accessors/stac.py</code> <pre><code>def current_state(self) -&gt; gpd.GeoDataFrame | None:\n    \"\"\"Get info about currently stored tiles.\n\n    Returns:\n        gpd.GeoDataFrame: Tile info from pystac. None if datacube is empty.\n\n\n    \"\"\"\n    import geopandas as gpd\n    import pystac_client\n\n    if not self.created:\n        return None\n\n    session = self.repo.readonly_session(\"main\")\n    zcube = zarr.open(session.store, mode=\"r\")\n    loaded_tiles = zcube.attrs.get(\"loaded_tiles\", [])\n\n    if len(loaded_tiles) == 0:\n        return None\n\n    catalog = pystac_client.Client.open(self.stac_api_url)\n    search = catalog.search(collections=[self.collection], ids=loaded_tiles)\n    stac_json = search.item_collection_as_dict()\n\n    gdf = gpd.GeoDataFrame.from_features(stac_json, \"epsg:4326\")\n    return gdf\n</code></pre>"},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors.STACAccessor.download_tile","title":"download_tile","text":"<pre><code>download_tile(zcube: Group, stac_tile: TileWrapper)\n</code></pre> <p>Download a tile from a STAC API and write it to a zarr datacube.</p> <p>Parameters:</p> Source code in <code>src/smart_geocubes/accessors/stac.py</code> <pre><code>def download_tile(self, zcube: zarr.Group, stac_tile: TileWrapper):\n    \"\"\"Download a tile from a STAC API and write it to a zarr datacube.\n\n    Args:\n        zcube (zarr.Array): The zarr datacube to write the tile to.\n        stac_tile (TileWrapper): The tile to download and write.\n\n    \"\"\"\n    from odc.stac import stac_load\n\n    tile = stac_load([stac_tile.item], bands=self.channels, chunks=None, progress=None)\n\n    # TODO: Allow for multi-temporal datacubes\n    tile = tile.max(\"time\")\n\n    # Get the slice of the datacube where the tile will be written\n    logger.debug(\n        f\"{stac_tile.id=}: {tile.sizes=} {tile.x[0].item()=} {tile.y[0].item()=} {zcube['x'][0]=} {zcube['y'][0]=}\"\n    )\n    tile = correct_bounds(tile, self.zgeobox)\n    target_slice = self.zgeobox.overlap_roi(tile.odc.geobox)\n\n    logger.debug(f\"tile.id={stac_tile.id}: Writing to {target_slice=}\")\n\n    for channel in self.channels:\n        raw_data = tile[channel].values\n        # Sometimes the data downloaded from stac has nan-borders, which would overwrite existing data\n        # Replace these nan borders with existing data if there is any\n        raw_data = np.where(~np.isnan(raw_data), raw_data, zcube[channel][target_slice])\n        zcube[channel][target_slice] = raw_data\n</code></pre>"},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors.STACAccessor.download_tile(zcube)","title":"<code>zcube</code>","text":"(<code>Array</code>)           \u2013            <p>The zarr datacube to write the tile to.</p>"},{"location":"reference/smart_geocubes/accessors/#smart_geocubes.accessors.STACAccessor.download_tile(stac_tile)","title":"<code>stac_tile</code>","text":"(<code>TileWrapper</code>)           \u2013            <p>The tile to download and write.</p>"},{"location":"reference/smart_geocubes/accessors/base/","title":"smart_geocubes.accessors.base","text":""},{"location":"reference/smart_geocubes/accessors/base/#smart_geocubes.accessors.base","title":"smart_geocubes.accessors.base","text":"<p>Base class for remote accessors.</p> <p>Classes:</p> <ul> <li> <code>LoadParams</code>           \u2013            <p>TypedDict for the load function parameters.</p> </li> <li> <code>RemoteAccessor</code>           \u2013            <p>Base class for remote accessors.</p> </li> <li> <code>TileWrapper</code>           \u2013            <p>Wrapper for a tile with an id.</p> </li> </ul>"},{"location":"reference/smart_geocubes/accessors/base/#smart_geocubes.accessors.base.LoadParams","title":"LoadParams","text":"<p>               Bases: <code>TypedDict</code></p> <p>TypedDict for the load function parameters.</p>"},{"location":"reference/smart_geocubes/accessors/base/#smart_geocubes.accessors.base.RemoteAccessor","title":"RemoteAccessor","text":"<pre><code>RemoteAccessor(\n    storage: Storage | Path | str,\n    create_icechunk_storage: bool = True,\n    title: str | None = None,\n    extent: GeoBox | None = None,\n    chunk_size: int | None = None,\n    channels: list | None = None,\n    channels_meta: dict | None = None,\n    channels_encoding: dict | None = None,\n)\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>Base class for remote accessors.</p> <p>Initialize base class for remote accessors.</p> <p>Warning</p> <p>In a multiprocessing environment, it is strongly recommended to not set <code>create_icechunk_storage=False</code>.</p> <p>The arguments <code>title</code>, <code>extent</code>, <code>chunk_size</code>, <code>channels</code>, <code>channels_meta</code> and <code>channels_encoding</code> will overwrite the dataset defaults and are only considered for the creation of a new datacube. It is strongly recommended to not set these values manually.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the storage is not an icechunk.Storage.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>adjacent_tiles</code>             \u2013              <p>Get the adjacent tiles for the given geobox.</p> </li> <li> <code>assert_created</code>             \u2013              <p>Assert that the datacube exists in the storage.</p> </li> <li> <code>create</code>             \u2013              <p>Create an empty datacube and write it to the store.</p> </li> <li> <code>current_state</code>             \u2013              <p>Get info about currently stored tiles / chunk.</p> </li> <li> <code>download_tile</code>             \u2013              <p>Download the data for the given tile.</p> </li> <li> <code>load</code>             \u2013              <p>Load the data for the given geobox.</p> </li> <li> <code>load_like</code>             \u2013              <p>Load the data for the given geobox.</p> </li> <li> <code>log_benchmark_summary</code>             \u2013              <p>Log the benchmark summary.</p> </li> <li> <code>open_xarray</code>             \u2013              <p>Open the xarray datacube in read-only mode.</p> </li> <li> <code>open_zarr</code>             \u2013              <p>Open the zarr datacube in read-only mode.</p> </li> <li> <code>post_create</code>             \u2013              <p>Post create actions. Can be overwritten by the dataset accessor.</p> </li> <li> <code>procedural_download</code>             \u2013              <p>Download the data for the given geobox.</p> </li> <li> <code>procedural_download_blocking</code>             \u2013              <p>Download tiles procedurally in blocking mode.</p> </li> <li> <code>procedural_download_threading</code>             \u2013              <p>Download tiles procedurally in threading mode.</p> </li> <li> <code>visualize_state</code>             \u2013              <p>Visulize currently stored tiles / chunk.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>created</code>               (<code>bool</code>)           \u2013            <p>Check if the datacube already exists in the storage.</p> </li> <li> <code>zgeobox</code>               (<code>GeoBox</code>)           \u2013            <p>Turn a zarr datacube into a GeoBox.</p> </li> </ul> Source code in <code>src/smart_geocubes/accessors/base.py</code> <pre><code>def __init__(\n    self,\n    storage: icechunk.Storage | Path | str,\n    create_icechunk_storage: bool = True,\n    title: str | None = None,\n    extent: GeoBox | None = None,\n    chunk_size: int | None = None,\n    channels: list | None = None,\n    channels_meta: dict | None = None,\n    channels_encoding: dict | None = None,\n):\n    \"\"\"Initialize base class for remote accessors.\n\n    !!! warning\n\n        In a multiprocessing environment, it is strongly recommended to not set `create_icechunk_storage=False`.\n\n    The arguments `title`, `extent`, `chunk_size`, `channels`, `channels_meta` and `channels_encoding`\n    will overwrite the dataset defaults and are only considered for the creation of a new datacube.\n    It is strongly recommended to not set these values manually.\n\n    Args:\n        storage (icechunk.Storage): The icechunk storage of the datacube.\n        create_icechunk_storage (bool, optional): If an icechunk repository should be created at provided storage\n            if no exists.\n            This should be disabled in a multiprocessing environment.\n            Defaults to True.\n        title (str | None, optional): The title of the datacube. Defaults to None.\n        extent (GeoBox | None, optional): The extent of the datacube. Defaults to None.\n        chunk_size (int | None, optional): The chunk size of the datacube. Defaults to None.\n        channels (list | None, optional): The channels of the datacube. Defaults to None.\n        channels_meta (dict | None, optional): The channels meta of the datacube. Defaults to None.\n        channels_encoding (dict | None, optional): The channels encoding of the datacube. Defaults to None.\n\n    Raises:\n        ValueError: If the storage is not an icechunk.Storage.\n\n    \"\"\"\n    if isinstance(storage, (str | Path)):\n        storage = storage if isinstance(storage, str) else str(storage.resolve())\n        storage = icechunk.local_filesystem_storage(storage)\n    if not isinstance(storage, icechunk.Storage):\n        raise ValueError(f\"Expected an icechunk.Storage, but got {type(storage)}\")\n    self.storage = storage\n    logger.debug(f\"Using storage {storage=}\")\n    if create_icechunk_storage:\n        self.repo = icechunk.Repository.open_or_create(storage)  # Will create a \"main\" branch\n    else:\n        self.repo = icechunk.Repository.open(storage)\n    logger.debug(f\"Using repository {self.repo=}\")\n\n    # We overwrite optionally the dataset attributes with user defined settings\n    self.title = title or type(self).__name__\n    if extent is not None:\n        self.extent = extent\n    if chunk_size is not None:\n        self.chunk_size = chunk_size\n    if channels is not None:\n        self.channels = channels\n    if channels_meta is not None:\n        self.channels_meta\n    if channels_encoding is not None:\n        self.channels_encoding\n\n    # TODO: store the settings variables in metadata and validate here\n\n    # The benchmarking timer for this accessor\n    self.stopuhr = StopUhr(logger.debug)\n\n    # The TypeVar used by the ThreadingHandler was added in 3.12\n    # The Shutdown method of the queue was added in 3.13\n    # Hence, we don't want to import the module unless Python 3.13 is installed\n    if _check_python_version(3, 13):\n        from smart_geocubes.concurrency.threading import ThreadingHandler\n\n        self.threading_handler = ThreadingHandler(self._threading_download)\n</code></pre>"},{"location":"reference/smart_geocubes/accessors/base/#smart_geocubes.accessors.base.RemoteAccessor(storage)","title":"<code>storage</code>","text":"(<code>Storage</code>)           \u2013            <p>The icechunk storage of the datacube.</p>"},{"location":"reference/smart_geocubes/accessors/base/#smart_geocubes.accessors.base.RemoteAccessor(create_icechunk_storage)","title":"<code>create_icechunk_storage</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If an icechunk repository should be created at provided storage if no exists. This should be disabled in a multiprocessing environment. Defaults to True.</p>"},{"location":"reference/smart_geocubes/accessors/base/#smart_geocubes.accessors.base.RemoteAccessor(title)","title":"<code>title</code>","text":"(<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The title of the datacube. Defaults to None.</p>"},{"location":"reference/smart_geocubes/accessors/base/#smart_geocubes.accessors.base.RemoteAccessor(extent)","title":"<code>extent</code>","text":"(<code>GeoBox | None</code>, default:                   <code>None</code> )           \u2013            <p>The extent of the datacube. Defaults to None.</p>"},{"location":"reference/smart_geocubes/accessors/base/#smart_geocubes.accessors.base.RemoteAccessor(chunk_size)","title":"<code>chunk_size</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The chunk size of the datacube. Defaults to None.</p>"},{"location":"reference/smart_geocubes/accessors/base/#smart_geocubes.accessors.base.RemoteAccessor(channels)","title":"<code>channels</code>","text":"(<code>list | None</code>, default:                   <code>None</code> )           \u2013            <p>The channels of the datacube. Defaults to None.</p>"},{"location":"reference/smart_geocubes/accessors/base/#smart_geocubes.accessors.base.RemoteAccessor(channels_meta)","title":"<code>channels_meta</code>","text":"(<code>dict | None</code>, default:                   <code>None</code> )           \u2013            <p>The channels meta of the datacube. Defaults to None.</p>"},{"location":"reference/smart_geocubes/accessors/base/#smart_geocubes.accessors.base.RemoteAccessor(channels_encoding)","title":"<code>channels_encoding</code>","text":"(<code>dict | None</code>, default:                   <code>None</code> )           \u2013            <p>The channels encoding of the datacube. Defaults to None.</p>"},{"location":"reference/smart_geocubes/accessors/base/#smart_geocubes.accessors.base.RemoteAccessor.created","title":"created  <code>property</code>","text":"<pre><code>created: bool\n</code></pre> <p>Check if the datacube already exists in the storage.</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if the datacube already exists in the storage.</p> </li> </ul>"},{"location":"reference/smart_geocubes/accessors/base/#smart_geocubes.accessors.base.RemoteAccessor.zgeobox","title":"zgeobox  <code>cached</code> <code>property</code>","text":"<pre><code>zgeobox: GeoBox\n</code></pre> <p>Turn a zarr datacube into a GeoBox.</p> <p>This SHOULD be equal to the .extent geobox. However, this property is used to find the target index of the downloaded data, so better save than sorry.</p> <p>Returns:</p> <ul> <li> <code>GeoBox</code> (              <code>GeoBox</code> )          \u2013            <p>The GeoBox created from the zarr datacube.</p> </li> </ul>"},{"location":"reference/smart_geocubes/accessors/base/#smart_geocubes.accessors.base.RemoteAccessor.adjacent_tiles","title":"adjacent_tiles  <code>abstractmethod</code>","text":"<pre><code>adjacent_tiles(geobox: GeoBox) -&gt; list[TileWrapper]\n</code></pre> <p>Get the adjacent tiles for the given geobox.</p> <p>Must be implemented by the Accessor.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[TileWrapper]</code>           \u2013            <p>list[TileWrapper]: The adjacent tile(-id)s for the given geobox.</p> </li> </ul> Source code in <code>src/smart_geocubes/accessors/base.py</code> <pre><code>@abstractmethod\ndef adjacent_tiles(self, geobox: GeoBox) -&gt; list[TileWrapper]:\n    \"\"\"Get the adjacent tiles for the given geobox.\n\n    Must be implemented by the Accessor.\n\n    Args:\n        geobox (GeoBox): The reference geobox to get the adjacent tiles for.\n\n    Returns:\n        list[TileWrapper]: The adjacent tile(-id)s for the given geobox.\n\n    \"\"\"\n</code></pre>"},{"location":"reference/smart_geocubes/accessors/base/#smart_geocubes.accessors.base.RemoteAccessor.adjacent_tiles(geobox)","title":"<code>geobox</code>","text":"(<code>GeoBox</code>)           \u2013            <p>The reference geobox to get the adjacent tiles for.</p>"},{"location":"reference/smart_geocubes/accessors/base/#smart_geocubes.accessors.base.RemoteAccessor.assert_created","title":"assert_created","text":"<pre><code>assert_created()\n</code></pre> <p>Assert that the datacube exists in the storage.</p> <p>Raises:</p> <ul> <li> <code>FileNotFoundError</code>             \u2013            <p>If the datacube does not exist.</p> </li> </ul> Source code in <code>src/smart_geocubes/accessors/base.py</code> <pre><code>def assert_created(self):\n    \"\"\"Assert that the datacube exists in the storage.\n\n    Raises:\n        FileNotFoundError: If the datacube does not exist.\n\n    \"\"\"\n    if not self.created:\n        msg = f\"Datacube {self.title} does not exist.\"\n        \" Please use the `create` method or pass `create=True` to `load`.\"\n        logger.error(msg)\n        raise FileNotFoundError(msg)\n</code></pre>"},{"location":"reference/smart_geocubes/accessors/base/#smart_geocubes.accessors.base.RemoteAccessor.create","title":"create","text":"<pre><code>create(overwrite: bool = False)\n</code></pre> <p>Create an empty datacube and write it to the store.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>FileExistsError</code>             \u2013            <p>If a datacube already exists at location</p> </li> </ul> Source code in <code>src/smart_geocubes/accessors/base.py</code> <pre><code>def create(self, overwrite: bool = False):\n    \"\"\"Create an empty datacube and write it to the store.\n\n    Args:\n        overwrite (bool, optional): Allowing overwriting an existing datacube. Defaults to False.\n\n    Raises:\n        FileExistsError: If a datacube already exists at location\n\n    \"\"\"\n    with self.stopuhr(\"Empty datacube creation\"):\n        # Check if the zarr data already exists\n        session = self.repo.writable_session(\"main\")\n        cube_is_empty = sync(session.store.is_empty(\"\"))\n        if not overwrite and not cube_is_empty:\n            logger.debug(f\"Unable to create a new datacube. {overwrite=} {cube_is_empty=} {session.store=}\")\n            raise FileExistsError(f\"Cannot create a new  datacube. {session.store=} is not empty!\")\n\n        logger.debug(\n            f\"Creating an empty zarr datacube '{self.title}' with the variables\"\n            f\" {self.channels} at a {self.extent.resolution=} (epsg:{self.extent.crs.epsg})\"\n            f\" and {self.chunk_size=} to {session.store=}\"\n        )\n\n        ds = xr.Dataset(\n            {\n                name: odc.geo.xr.xr_zeros(\n                    self.extent,\n                    chunks=-1,\n                    dtype=self.channels_encoding[name].get(\"dtype\", \"float32\"),\n                    always_yx=True,\n                )\n                for name in self.channels\n            },\n            attrs={\"title\": self.title, \"loaded_tiles\": []},\n        )\n\n        # Add metadata\n        for name, meta in self.channels_meta.items():\n            ds[name].attrs.update(meta)\n\n        # Get the encoding for the coordinates, variables and spatial reference\n        coords_encoding = {\n            \"x\": {\"chunks\": ds.x.shape, **optimize_coord_encoding(ds.x.values, self.extent.resolution.x)},\n            \"y\": {\"chunks\": ds.y.shape, **optimize_coord_encoding(ds.y.values, self.extent.resolution.y)},\n        }\n        var_encoding = {\n            name: {\n                \"chunks\": (self.chunk_size, self.chunk_size),\n                \"compressors\": [BloscCodec(clevel=9)],\n                **self.channels_encoding[name],\n            }\n            for name in self.channels\n        }\n        encoding = {\n            \"spatial_ref\": {\"chunks\": None, \"dtype\": \"int32\"},\n            **coords_encoding,\n            **var_encoding,\n        }\n        logger.debug(f\"Datacube {encoding=}\")\n\n        ds.to_zarr(\n            session.store,\n            encoding=encoding,\n            compute=False,\n            consolidated=False,\n            zarr_format=3,\n            mode=\"w\" if overwrite else \"w-\",\n        )\n\n        commit = session.commit(\"Initialize empty datacube\")\n        logger.debug(f\"Datacube created: {commit=}\")\n\n        self.post_create()\n</code></pre>"},{"location":"reference/smart_geocubes/accessors/base/#smart_geocubes.accessors.base.RemoteAccessor.create(overwrite)","title":"<code>overwrite</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Allowing overwriting an existing datacube. Defaults to False.</p>"},{"location":"reference/smart_geocubes/accessors/base/#smart_geocubes.accessors.base.RemoteAccessor.current_state","title":"current_state  <code>abstractmethod</code>","text":"<pre><code>current_state() -&gt; gpd.GeoDataFrame | None\n</code></pre> <p>Get info about currently stored tiles / chunk.</p> <p>Must be implemented by the Accessor.</p> <p>Returns:</p> <ul> <li> <code>GeoDataFrame | None</code>           \u2013            <p>gpd.GeoDataFrame | None: Tile or Chunk info.</p> </li> </ul> Source code in <code>src/smart_geocubes/accessors/base.py</code> <pre><code>@abstractmethod\ndef current_state(self) -&gt; gpd.GeoDataFrame | None:\n    \"\"\"Get info about currently stored tiles / chunk.\n\n    Must be implemented by the Accessor.\n\n    Returns:\n        gpd.GeoDataFrame | None: Tile or Chunk info.\n\n    \"\"\"\n</code></pre>"},{"location":"reference/smart_geocubes/accessors/base/#smart_geocubes.accessors.base.RemoteAccessor.download_tile","title":"download_tile  <code>abstractmethod</code>","text":"<pre><code>download_tile(zcube: Array, tile: TileWrapper)\n</code></pre> <p>Download the data for the given tile.</p> <p>Must be implemented by the Accessor.</p> <p>Parameters:</p> Source code in <code>src/smart_geocubes/accessors/base.py</code> <pre><code>@abstractmethod\ndef download_tile(self, zcube: zarr.Array, tile: TileWrapper):\n    \"\"\"Download the data for the given tile.\n\n    Must be implemented by the Accessor.\n\n    Args:\n        zcube (zarr.Array): The datacube to write the tile data to.\n        tile (TileWrapper): The reference tile to download the data for.\n\n    \"\"\"\n</code></pre>"},{"location":"reference/smart_geocubes/accessors/base/#smart_geocubes.accessors.base.RemoteAccessor.download_tile(zcube)","title":"<code>zcube</code>","text":"(<code>Array</code>)           \u2013            <p>The datacube to write the tile data to.</p>"},{"location":"reference/smart_geocubes/accessors/base/#smart_geocubes.accessors.base.RemoteAccessor.download_tile(tile)","title":"<code>tile</code>","text":"(<code>TileWrapper</code>)           \u2013            <p>The reference tile to download the data for.</p>"},{"location":"reference/smart_geocubes/accessors/base/#smart_geocubes.accessors.base.RemoteAccessor.load","title":"load","text":"<pre><code>load(\n    geobox: GeoBox,\n    buffer: int = 0,\n    persist: bool = True,\n    create: bool = False,\n    concurrency_mode: ConcurrencyModes = \"blocking\",\n) -&gt; xr.Dataset\n</code></pre> <p>Load the data for the given geobox.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Dataset</code>           \u2013            <p>xr.Dataset: The loaded dataset in the same resolution and extent like the geobox.</p> </li> </ul> Source code in <code>src/smart_geocubes/accessors/base.py</code> <pre><code>def load(\n    self,\n    geobox: GeoBox,\n    buffer: int = 0,\n    persist: bool = True,\n    create: bool = False,\n    concurrency_mode: ConcurrencyModes = \"blocking\",\n) -&gt; xr.Dataset:\n    \"\"\"Load the data for the given geobox.\n\n    Args:\n        geobox (GeoBox): The reference geobox to load the data for.\n        buffer (int, optional): The buffer around the projected geobox in pixels. Defaults to 0.\n        persist (bool, optional): If the data should be persisted in memory.\n            If not, this will return a Dask backed Dataset. Defaults to True.\n        create (bool, optional): Create a new zarr array at defined storage if it not exists.\n            This is not recommended, because it can have side effects in a multi-process environment.\n            Defaults to False.\n        concurrency_mode (ConcurrencyModes, optional): The concurrency mode for the download.\n            Defaults to \"blocking\".\n\n    Returns:\n        xr.Dataset: The loaded dataset in the same resolution and extent like the geobox.\n\n    \"\"\"\n    with self.stopuhr(f\"{geobox=}: {self.title} tile {'loading' if persist else 'lazy-loading'}\"):\n        logger.debug(f\"{geobox=}: {geobox.resolution.x}m original resolution\")\n\n        # Create the datacube if it does not exist\n        if create:\n            try:\n                self.create(overwrite=False)\n            except FileExistsError:  # We are okay if the datacube already exists\n                pass\n        else:\n            # Check if the datacube exists\n            self.assert_created()\n\n        # Download the adjacent tiles (if necessary)\n        reference_geobox = geobox.to_crs(self.extent.crs, resolution=self.extent.resolution.x).pad(buffer)\n        self.procedural_download(reference_geobox, concurrency_mode=concurrency_mode)\n\n        # Load the datacube and set the spatial_ref since it is set as a coordinate within the zarr format\n        session = self.repo.readonly_session(\"main\")\n        chunks = None if persist else \"auto\"\n        xrcube = xr.open_zarr(\n            session.store,\n            mask_and_scale=False,\n            chunks=chunks,\n            consolidated=False,\n        ).set_coords(\"spatial_ref\")\n\n        # Get an AOI slice of the datacube\n        xrcube_aoi = xrcube.odc.crop(reference_geobox.extent, apply_mask=False)\n\n        # The following code would load the lazy zarr data from disk into memory\n        if persist:\n            with self.stopuhr(f\"{geobox=}: {self.title} AOI loading from disk\"):\n                xrcube_aoi = xrcube_aoi.load()\n    return xrcube_aoi\n</code></pre>"},{"location":"reference/smart_geocubes/accessors/base/#smart_geocubes.accessors.base.RemoteAccessor.load(geobox)","title":"<code>geobox</code>","text":"(<code>GeoBox</code>)           \u2013            <p>The reference geobox to load the data for.</p>"},{"location":"reference/smart_geocubes/accessors/base/#smart_geocubes.accessors.base.RemoteAccessor.load(buffer)","title":"<code>buffer</code>","text":"(<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The buffer around the projected geobox in pixels. Defaults to 0.</p>"},{"location":"reference/smart_geocubes/accessors/base/#smart_geocubes.accessors.base.RemoteAccessor.load(persist)","title":"<code>persist</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If the data should be persisted in memory. If not, this will return a Dask backed Dataset. Defaults to True.</p>"},{"location":"reference/smart_geocubes/accessors/base/#smart_geocubes.accessors.base.RemoteAccessor.load(create)","title":"<code>create</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Create a new zarr array at defined storage if it not exists. This is not recommended, because it can have side effects in a multi-process environment. Defaults to False.</p>"},{"location":"reference/smart_geocubes/accessors/base/#smart_geocubes.accessors.base.RemoteAccessor.load(concurrency_mode)","title":"<code>concurrency_mode</code>","text":"(<code>ConcurrencyModes</code>, default:                   <code>'blocking'</code> )           \u2013            <p>The concurrency mode for the download. Defaults to \"blocking\".</p>"},{"location":"reference/smart_geocubes/accessors/base/#smart_geocubes.accessors.base.RemoteAccessor.load_like","title":"load_like","text":"<pre><code>load_like(\n    ref: Dataset | DataArray, **kwargs: Unpack[LoadParams]\n) -&gt; xr.Dataset\n</code></pre> <p>Load the data for the given geobox.</p> <p>Parameters:</p> <p>Other Parameters:</p> <ul> <li> <code>buffer</code>               (<code>int</code>)           \u2013            <p>The buffer around the projected geobox in pixels. Defaults to 0.</p> </li> <li> <code>persist</code>               (<code>bool</code>)           \u2013            <p>If the data should be persisted in memory. If not, this will return a Dask backed Dataset. Defaults to True.</p> </li> <li> <code>create</code>               (<code>bool</code>)           \u2013            <p>Create a new zarr array at defined storage if it not exists. This is not recommended, because it can have side effects in a multi-process environment. Defaults to False.</p> </li> <li> <code>concurrency_mode</code>               (<code>ConcurrencyModes</code>)           \u2013            <p>The concurrency mode for the download. Defaults to \"blocking\".</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dataset</code>           \u2013            <p>xr.Dataset: The loaded dataset in the same resolution and extent like the geobox.</p> </li> </ul> Source code in <code>src/smart_geocubes/accessors/base.py</code> <pre><code>def load_like(\n    self,\n    ref: xr.Dataset | xr.DataArray,\n    **kwargs: Unpack[LoadParams],\n) -&gt; xr.Dataset:\n    \"\"\"Load the data for the given geobox.\n\n    Args:\n        ref (xr.Dataset | xr.DataArray): The reference dataarray or dataset to load the data for.\n        **kwargs: The load parameters (buffer, persist, create, concurrency_mode).\n\n    Keyword Args:\n        buffer (int, optional): The buffer around the projected geobox in pixels. Defaults to 0.\n        persist (bool, optional): If the data should be persisted in memory.\n            If not, this will return a Dask backed Dataset. Defaults to True.\n        create (bool, optional): Create a new zarr array at defined storage if it not exists.\n            This is not recommended, because it can have side effects in a multi-process environment.\n            Defaults to False.\n        concurrency_mode (ConcurrencyModes, optional): The concurrency mode for the download.\n            Defaults to \"blocking\".\n\n    Returns:\n        xr.Dataset: The loaded dataset in the same resolution and extent like the geobox.\n\n    \"\"\"\n    return self.load(geobox=ref.geobox, **kwargs)\n</code></pre>"},{"location":"reference/smart_geocubes/accessors/base/#smart_geocubes.accessors.base.RemoteAccessor.load_like(ref)","title":"<code>ref</code>","text":"(<code>Dataset | DataArray</code>)           \u2013            <p>The reference dataarray or dataset to load the data for.</p>"},{"location":"reference/smart_geocubes/accessors/base/#smart_geocubes.accessors.base.RemoteAccessor.load_like(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Unpack[LoadParams]</code>, default:                   <code>{}</code> )           \u2013            <p>The load parameters (buffer, persist, create, concurrency_mode).</p>"},{"location":"reference/smart_geocubes/accessors/base/#smart_geocubes.accessors.base.RemoteAccessor.log_benchmark_summary","title":"log_benchmark_summary","text":"<pre><code>log_benchmark_summary()\n</code></pre> <p>Log the benchmark summary.</p> Source code in <code>src/smart_geocubes/accessors/base.py</code> <pre><code>def log_benchmark_summary(self):\n    \"\"\"Log the benchmark summary.\"\"\"\n    self.stopuhr.summary()\n</code></pre>"},{"location":"reference/smart_geocubes/accessors/base/#smart_geocubes.accessors.base.RemoteAccessor.open_xarray","title":"open_xarray","text":"<pre><code>open_xarray() -&gt; xr.Dataset\n</code></pre> <p>Open the xarray datacube in read-only mode.</p> <p>Returns:</p> <ul> <li> <code>Dataset</code>           \u2013            <p>xr.Dataset: The xarray datacube.</p> </li> </ul> Source code in <code>src/smart_geocubes/accessors/base.py</code> <pre><code>def open_xarray(self) -&gt; xr.Dataset:\n    \"\"\"Open the xarray datacube in read-only mode.\n\n    Returns:\n        xr.Dataset: The xarray datacube.\n\n    \"\"\"\n    self.assert_created()\n    session = self.repo.readonly_session(\"main\")\n    xcube = xr.open_zarr(session.store, mask_and_scale=False, consolidated=False).set_coords(\"spatial_ref\")\n    return xcube\n</code></pre>"},{"location":"reference/smart_geocubes/accessors/base/#smart_geocubes.accessors.base.RemoteAccessor.open_zarr","title":"open_zarr","text":"<pre><code>open_zarr() -&gt; zarr.Group\n</code></pre> <p>Open the zarr datacube in read-only mode.</p> <p>Returns:</p> <ul> <li> <code>Group</code>           \u2013            <p>zarr.Group: The zarr datacube.</p> </li> </ul> Source code in <code>src/smart_geocubes/accessors/base.py</code> <pre><code>def open_zarr(self) -&gt; zarr.Group:\n    \"\"\"Open the zarr datacube in read-only mode.\n\n    Returns:\n        zarr.Group: The zarr datacube.\n\n    \"\"\"\n    self.assert_created()\n    session = self.repo.readonly_session(\"main\")\n    zcube = zarr.open(store=session.store, mode=\"r\")\n    return zcube\n</code></pre>"},{"location":"reference/smart_geocubes/accessors/base/#smart_geocubes.accessors.base.RemoteAccessor.post_create","title":"post_create","text":"<pre><code>post_create()\n</code></pre> <p>Post create actions. Can be overwritten by the dataset accessor.</p> Source code in <code>src/smart_geocubes/accessors/base.py</code> <pre><code>def post_create(self):\n    \"\"\"Post create actions. Can be overwritten by the dataset accessor.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/smart_geocubes/accessors/base/#smart_geocubes.accessors.base.RemoteAccessor.procedural_download","title":"procedural_download","text":"<pre><code>procedural_download(\n    geobox: GeoBox,\n    concurrency_mode: ConcurrencyModes = \"blocking\",\n)\n</code></pre> <p>Download the data for the given geobox.</p> Note <p>The \"threading\" concurrency mode requires Python 3.13 or higher.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If an unknown concurrency mode is provided.</p> </li> </ul> Source code in <code>src/smart_geocubes/accessors/base.py</code> <pre><code>def procedural_download(self, geobox: GeoBox, concurrency_mode: ConcurrencyModes = \"blocking\"):\n    \"\"\"Download the data for the given geobox.\n\n    Note:\n        The \"threading\" concurrency mode requires Python 3.13 or higher.\n\n    Args:\n        geobox (GeoBox): The reference geobox to download the data for.\n        concurrency_mode (ConcurrencyModes, optional): The concurrency mode for the download.\n            Defaults to \"blocking\".\n\n    Raises:\n        ValueError: If an unknown concurrency mode is provided.\n\n    \"\"\"\n    self.assert_created()\n    if concurrency_mode == \"blocking\":\n        self.procedural_download_blocking(geobox)\n    elif concurrency_mode == \"threading\":\n        self.procedural_download_threading(geobox)\n    else:\n        raise ValueError(f\"Unknown concurrency mode {concurrency_mode}\")\n</code></pre>"},{"location":"reference/smart_geocubes/accessors/base/#smart_geocubes.accessors.base.RemoteAccessor.procedural_download(geobox)","title":"<code>geobox</code>","text":"(<code>GeoBox</code>)           \u2013            <p>The reference geobox to download the data for.</p>"},{"location":"reference/smart_geocubes/accessors/base/#smart_geocubes.accessors.base.RemoteAccessor.procedural_download(concurrency_mode)","title":"<code>concurrency_mode</code>","text":"(<code>ConcurrencyModes</code>, default:                   <code>'blocking'</code> )           \u2013            <p>The concurrency mode for the download. Defaults to \"blocking\".</p>"},{"location":"reference/smart_geocubes/accessors/base/#smart_geocubes.accessors.base.RemoteAccessor.procedural_download_blocking","title":"procedural_download_blocking","text":"<pre><code>procedural_download_blocking(\n    geobox: GeoBox, tries: int = 5\n)\n</code></pre> <p>Download tiles procedurally in blocking mode.</p> Warning <p>This method is meant for single-process use, but can (in theory) be used in a multi-process environment. However, in a multi-process environment it can happen that multiple processes try to write concurrently, which results in a conflict. In such cases, the download will be retried until it succeeds or the number of maximum-tries is reached.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If no adjacent tiles are found. This can happen if the geobox is out of the dataset bounds.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If no tries are left.</p> </li> </ul> Source code in <code>src/smart_geocubes/accessors/base.py</code> <pre><code>def procedural_download_blocking(self, geobox: GeoBox, tries: int = 5):\n    \"\"\"Download tiles procedurally in blocking mode.\n\n    Warning:\n        This method is meant for single-process use, but can (in theory) be used in a multi-process environment.\n        However, in a multi-process environment it can happen that multiple processes try to write concurrently,\n        which results in a conflict.\n        In such cases, the download will be retried until it succeeds or the number of maximum-tries is reached.\n\n    Args:\n        geobox (GeoBox): The geobox of the aoi to download.\n        tries (int, optional): Number of maximum tries. Defaults to 5.\n\n    Raises:\n        ValueError: If no adjacent tiles are found. This can happen if the geobox is out of the dataset bounds.\n        ValueError: If no tries are left.\n\n    \"\"\"\n    if tries == 0:\n        logger.warning(\"No tries left, skipping download\")\n        raise ValueError(\"Unable to commit, no tries left.\")\n\n    with self.stopuhr(f\"{geobox=}: Procedural download in blocking mode\"):\n        adjacent_tiles = self.adjacent_tiles(geobox)\n        if not adjacent_tiles:\n            logger.error(f\"{geobox=}: No adjacent tiles found: {adjacent_tiles=}\")\n            raise ValueError(\"No adjacent tiles found - is the provided geobox corrent?\")\n\n        session = self.repo.writable_session(\"main\")\n        zcube = zarr.open(store=session.store, mode=\"r+\")\n        loaded_tiles = zcube.attrs.get(\"loaded_tiles\", [])\n        new_tiles = [tile for tile in adjacent_tiles if tile.id not in loaded_tiles]\n        logger.debug(f\"{geobox=}:  {len(adjacent_tiles)=} &amp; {len(loaded_tiles)=} -&gt; {len(new_tiles)=} to download\")\n        if not new_tiles:\n            return\n\n        for tile in new_tiles:\n            with self.stopuhr(f\"{tile.id=}: Downloading one new tile in blocking mode\"):\n                logger.debug(f\"{tile.id=}: Start downloading\")\n                self.download_tile(zcube, tile)\n\n            loaded_tiles.append(tile.id)\n            zcube.attrs[\"loaded_tiles\"] = loaded_tiles\n\n        try:\n            # session.rebase(icechunk.ConflictDetector())\n            session.commit(f\"Procedurally downloaded tiles {[tile.id for tile in new_tiles]} in blocking mode\")\n        # Currently not possible, because attrs will always result in a conflict\n        # except icechunk.RebaseFailedError as e:\n        #     logger.warning(f\"Rebase failed: {e}\")\n        #     logger.debug(f\"Retrying download with {tries - 1} tries left\")\n        #     self.procedural_download_blocking(geobox, tries=tries - 1)\n        except icechunk.ConflictError as e:\n            logger.warning(f\"Icechunk session is out of sync: {e}\")\n            logger.debug(f\"Retrying download with {tries - 1} tries left\")\n            self.procedural_download_blocking(geobox, tries=tries - 1)\n</code></pre>"},{"location":"reference/smart_geocubes/accessors/base/#smart_geocubes.accessors.base.RemoteAccessor.procedural_download_blocking(geobox)","title":"<code>geobox</code>","text":"(<code>GeoBox</code>)           \u2013            <p>The geobox of the aoi to download.</p>"},{"location":"reference/smart_geocubes/accessors/base/#smart_geocubes.accessors.base.RemoteAccessor.procedural_download_blocking(tries)","title":"<code>tries</code>","text":"(<code>int</code>, default:                   <code>5</code> )           \u2013            <p>Number of maximum tries. Defaults to 5.</p>"},{"location":"reference/smart_geocubes/accessors/base/#smart_geocubes.accessors.base.RemoteAccessor.procedural_download_threading","title":"procedural_download_threading","text":"<pre><code>procedural_download_threading(geobox: GeoBox)\n</code></pre> <p>Download tiles procedurally in threading mode.</p> Note <p>This method ensures that only a single download is running at a time. It uses a SetQueue to prevent duplicate downloads. The threading mode requires Python 3.13 or higher.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If no adjacent tiles are found. This can happen if the geobox is out of the dataset bounds.</p> </li> <li> <code>RuntimeError</code>             \u2013            <p>If the Python version is lower than 3.13.</p> </li> </ul> Source code in <code>src/smart_geocubes/accessors/base.py</code> <pre><code>def procedural_download_threading(self, geobox: GeoBox):\n    \"\"\"Download tiles procedurally in threading mode.\n\n    Note:\n        This method ensures that only a single download is running at a time.\n        It uses a SetQueue to prevent duplicate downloads.\n        The threading mode requires Python 3.13 or higher.\n\n    Args:\n        geobox (GeoBox): The geobox of the aoi to download.\n\n    Raises:\n        ValueError: If no adjacent tiles are found. This can happen if the geobox is out of the dataset bounds.\n        RuntimeError: If the Python version is lower than 3.13.\n\n    \"\"\"\n    if not _check_python_version(3, 13):\n        raise RuntimeError(\"Threading mode requires Python 3.13 or higher\")\n    with self.threading_handler:\n        adjacent_tiles = self.adjacent_tiles(geobox)\n        if not adjacent_tiles:\n            logger.error(f\"{geobox=}: No adjacent tiles found: {adjacent_tiles=}\")\n            raise ValueError(\"No adjacent tiles found - is the provided geobox corrent?\")\n\n        # Wait until all new_items are loaded\n        prev_len = None\n        while True:\n            session = self.repo.readonly_session(\"main\")\n            zcube = zarr.open(store=session.store, mode=\"r\")\n            loaded_tiles = zcube.attrs.get(\"loaded_tiles\", [])\n            new_tiles = [tile for tile in adjacent_tiles if tile.id not in loaded_tiles]\n            done_tiles = [tile for tile in adjacent_tiles if tile.id in loaded_tiles]\n            if not new_tiles:\n                break\n            if prev_len != len(new_tiles):\n                logger.debug(\n                    f\"{geobox=}: {len(done_tiles)} of {len(adjacent_tiles)} downloaded.\"\n                    f\" Missing: {[t.id for t in new_tiles]} Done: {[t.id for t in done_tiles]}\"\n                )\n            for tile in new_tiles:\n                self.threading_handler._queue.put(tile)\n            prev_len = len(new_tiles)\n            time.sleep(5)\n</code></pre>"},{"location":"reference/smart_geocubes/accessors/base/#smart_geocubes.accessors.base.RemoteAccessor.procedural_download_threading(geobox)","title":"<code>geobox</code>","text":"(<code>GeoBox</code>)           \u2013            <p>The geobox of the aoi to download.</p>"},{"location":"reference/smart_geocubes/accessors/base/#smart_geocubes.accessors.base.RemoteAccessor.visualize_state","title":"visualize_state  <code>abstractmethod</code>","text":"<pre><code>visualize_state(\n    ax: Axes | None = None,\n) -&gt; plt.Figure | plt.Axes\n</code></pre> <p>Visulize currently stored tiles / chunk.</p> <p>Must be implemented by the DatasetAccessor.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Figure | Axes</code>           \u2013            <p>plt.Figure | plt.Axes: The figure with the visualization</p> </li> </ul> Source code in <code>src/smart_geocubes/accessors/base.py</code> <pre><code>@abstractmethod\ndef visualize_state(self, ax: \"plt.Axes | None\" = None) -&gt; \"plt.Figure | plt.Axes\":\n    \"\"\"Visulize currently stored tiles / chunk.\n\n    Must be implemented by the DatasetAccessor.\n\n    Args:\n        ax (plt.Axes | None, optional): The axes drawn to. If None, will create a new figure and axes.\n            Defaults to None.\n\n    Returns:\n        plt.Figure | plt.Axes: The figure with the visualization\n\n    \"\"\"\n</code></pre>"},{"location":"reference/smart_geocubes/accessors/base/#smart_geocubes.accessors.base.RemoteAccessor.visualize_state(ax)","title":"<code>ax</code>","text":"(<code>Axes | None</code>, default:                   <code>None</code> )           \u2013            <p>The axes drawn to. If None, will create a new figure and axes. Defaults to None.</p>"},{"location":"reference/smart_geocubes/accessors/base/#smart_geocubes.accessors.base.TileWrapper","title":"TileWrapper","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Wrapper for a tile with an id.</p>"},{"location":"reference/smart_geocubes/accessors/gee/","title":"smart_geocubes.accessors.gee","text":""},{"location":"reference/smart_geocubes/accessors/gee/#smart_geocubes.accessors.gee","title":"smart_geocubes.accessors.gee","text":"<p>Google Earth Engine Accessor for Smart Geocubes.</p> <p>Classes:</p> <ul> <li> <code>GEEAccessor</code>           \u2013            <p>Accessor for Google Earth Engine data.</p> </li> </ul>"},{"location":"reference/smart_geocubes/accessors/gee/#smart_geocubes.accessors.gee.GEEAccessor","title":"GEEAccessor","text":"<pre><code>GEEAccessor(\n    storage: Storage | Path | str,\n    create_icechunk_storage: bool = True,\n    title: str | None = None,\n    extent: GeoBox | None = None,\n    chunk_size: int | None = None,\n    channels: list | None = None,\n    channels_meta: dict | None = None,\n    channels_encoding: dict | None = None,\n)\n</code></pre> <p>               Bases: <code>RemoteAccessor</code></p> <p>Accessor for Google Earth Engine data.</p> <p>Methods:</p> <ul> <li> <code>adjacent_tiles</code>             \u2013              <p>Get adjacent tiles from Google Earth Engine.</p> </li> <li> <code>current_state</code>             \u2013              <p>Get info about currently stored tiles.</p> </li> <li> <code>download_tile</code>             \u2013              <p>Download a tile from Google Earth Engine.</p> </li> </ul> Source code in <code>src/smart_geocubes/accessors/base.py</code> <pre><code>def __init__(\n    self,\n    storage: icechunk.Storage | Path | str,\n    create_icechunk_storage: bool = True,\n    title: str | None = None,\n    extent: GeoBox | None = None,\n    chunk_size: int | None = None,\n    channels: list | None = None,\n    channels_meta: dict | None = None,\n    channels_encoding: dict | None = None,\n):\n    \"\"\"Initialize base class for remote accessors.\n\n    !!! warning\n\n        In a multiprocessing environment, it is strongly recommended to not set `create_icechunk_storage=False`.\n\n    The arguments `title`, `extent`, `chunk_size`, `channels`, `channels_meta` and `channels_encoding`\n    will overwrite the dataset defaults and are only considered for the creation of a new datacube.\n    It is strongly recommended to not set these values manually.\n\n    Args:\n        storage (icechunk.Storage): The icechunk storage of the datacube.\n        create_icechunk_storage (bool, optional): If an icechunk repository should be created at provided storage\n            if no exists.\n            This should be disabled in a multiprocessing environment.\n            Defaults to True.\n        title (str | None, optional): The title of the datacube. Defaults to None.\n        extent (GeoBox | None, optional): The extent of the datacube. Defaults to None.\n        chunk_size (int | None, optional): The chunk size of the datacube. Defaults to None.\n        channels (list | None, optional): The channels of the datacube. Defaults to None.\n        channels_meta (dict | None, optional): The channels meta of the datacube. Defaults to None.\n        channels_encoding (dict | None, optional): The channels encoding of the datacube. Defaults to None.\n\n    Raises:\n        ValueError: If the storage is not an icechunk.Storage.\n\n    \"\"\"\n    if isinstance(storage, (str | Path)):\n        storage = storage if isinstance(storage, str) else str(storage.resolve())\n        storage = icechunk.local_filesystem_storage(storage)\n    if not isinstance(storage, icechunk.Storage):\n        raise ValueError(f\"Expected an icechunk.Storage, but got {type(storage)}\")\n    self.storage = storage\n    logger.debug(f\"Using storage {storage=}\")\n    if create_icechunk_storage:\n        self.repo = icechunk.Repository.open_or_create(storage)  # Will create a \"main\" branch\n    else:\n        self.repo = icechunk.Repository.open(storage)\n    logger.debug(f\"Using repository {self.repo=}\")\n\n    # We overwrite optionally the dataset attributes with user defined settings\n    self.title = title or type(self).__name__\n    if extent is not None:\n        self.extent = extent\n    if chunk_size is not None:\n        self.chunk_size = chunk_size\n    if channels is not None:\n        self.channels = channels\n    if channels_meta is not None:\n        self.channels_meta\n    if channels_encoding is not None:\n        self.channels_encoding\n\n    # TODO: store the settings variables in metadata and validate here\n\n    # The benchmarking timer for this accessor\n    self.stopuhr = StopUhr(logger.debug)\n\n    # The TypeVar used by the ThreadingHandler was added in 3.12\n    # The Shutdown method of the queue was added in 3.13\n    # Hence, we don't want to import the module unless Python 3.13 is installed\n    if _check_python_version(3, 13):\n        from smart_geocubes.concurrency.threading import ThreadingHandler\n\n        self.threading_handler = ThreadingHandler(self._threading_download)\n</code></pre>"},{"location":"reference/smart_geocubes/accessors/gee/#smart_geocubes.accessors.gee.GEEAccessor.adjacent_tiles","title":"adjacent_tiles","text":"<pre><code>adjacent_tiles(geobox: GeoBox) -&gt; list[TileWrapper]\n</code></pre> <p>Get adjacent tiles from Google Earth Engine.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[TileWrapper]</code>           \u2013            <p>list[TileWrapper]: List of adjacent tiles, wrapped in own datastructure for easier processing.</p> </li> </ul> Source code in <code>src/smart_geocubes/accessors/gee.py</code> <pre><code>def adjacent_tiles(self, geobox: GeoBox) -&gt; list[TileWrapper]:\n    \"\"\"Get adjacent tiles from Google Earth Engine.\n\n    Args:\n        geobox (GeoBox): The geobox for which to get adjacent tiles.\n\n    Returns:\n        list[TileWrapper]: List of adjacent tiles, wrapped in own datastructure for easier processing.\n\n    \"\"\"\n    tiles = GeoboxTiles(self.extent, (self.chunk_size, self.chunk_size))\n    return [TileWrapper(_tileidx_to_id(idx), tiles[idx]) for idx in tiles.tiles(geobox.extent)]\n</code></pre>"},{"location":"reference/smart_geocubes/accessors/gee/#smart_geocubes.accessors.gee.GEEAccessor.adjacent_tiles(geobox)","title":"<code>geobox</code>","text":"(<code>GeoBox</code>)           \u2013            <p>The geobox for which to get adjacent tiles.</p>"},{"location":"reference/smart_geocubes/accessors/gee/#smart_geocubes.accessors.gee.GEEAccessor.current_state","title":"current_state","text":"<pre><code>current_state() -&gt; gpd.GeoDataFrame | None\n</code></pre> <p>Get info about currently stored tiles.</p> <p>Returns:</p> <ul> <li> <code>GeoDataFrame | None</code>           \u2013            <p>gpd.GeoDataFrame: Tiles from odc.geo.GeoboxTiles. None if datacube is empty.</p> </li> </ul> Source code in <code>src/smart_geocubes/accessors/gee.py</code> <pre><code>def current_state(self) -&gt; gpd.GeoDataFrame | None:\n    \"\"\"Get info about currently stored tiles.\n\n    Returns:\n        gpd.GeoDataFrame: Tiles from odc.geo.GeoboxTiles. None if datacube is empty.\n\n    \"\"\"\n    import geopandas as gpd\n\n    if not self.created:\n        return None\n\n    session = self.repo.readonly_session(\"main\")\n    zcube = zarr.open(session.store, mode=\"r\")\n    loaded_tiles = zcube.attrs.get(\"loaded_tiles\", [])\n\n    if len(loaded_tiles) == 0:\n        return None\n\n    tiles = GeoboxTiles(self.extent, (self.chunk_size, self.chunk_size))\n    loaded_tiles = [{\"geometry\": tiles[_id_to_tileidx(tid)].extent.geom, \"id\": tid} for tid in loaded_tiles]\n    gdf = gpd.GeoDataFrame(loaded_tiles, crs=self.extent.crs.to_wkt())\n    return gdf\n</code></pre>"},{"location":"reference/smart_geocubes/accessors/gee/#smart_geocubes.accessors.gee.GEEAccessor.download_tile","title":"download_tile","text":"<pre><code>download_tile(zcube: Group, geobox_tile: TileWrapper)\n</code></pre> <p>Download a tile from Google Earth Engine.</p> <p>Parameters:</p> Source code in <code>src/smart_geocubes/accessors/gee.py</code> <pre><code>def download_tile(self, zcube: zarr.Group, geobox_tile: TileWrapper):\n    \"\"\"Download a tile from Google Earth Engine.\n\n    Args:\n        zcube (zarr.Group): The zarr datacube to download the tile to.\n        geobox_tile (TileWrapper): The tile to download.\n\n    \"\"\"\n    import ee\n    import rioxarray  # noqa: F401\n    import xee  # noqa: F401\n\n    # Note: This is a little bit weird: First we create an own grid which overlaps to the chunks\n    # of the zarr array. Then we create a mosaic of the data and clip it to a single chunk.\n    # We could load the images from the collection directly instead of creating a mosaic.\n    # However, this would require more testing and probably results a lot of manual computation\n    # of slices etc. like in the stac variant. So for now, we just use the mosaic.\n    logging.getLogger(\"urllib3.connectionpool\").disabled = True\n    geom = ee.Geometry.Rectangle(geobox_tile.item.geographic_extent.boundingbox)\n    ee_img = ee.ImageCollection(self.collection).mosaic().clip(geom)\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\"ignore\", category=UserWarning, message=EE_WARN_MSG)\n        tile = xr.open_dataset(\n            ee_img,\n            engine=\"ee\",\n            geometry=geom,\n            crs=f\"epsg:{self.extent.crs.to_epsg()}\",\n            scale=self.extent.resolution.x,\n        )\n\n    # TODO: Allow for multi-temporal datacubes and lat/lon coordinates\n    tile = tile.max(\"time\").rename({\"lon\": \"x\", \"lat\": \"y\"}).transpose(\"y\", \"x\")\n\n    # Download the data\n    tile.load()\n    logging.getLogger(\"urllib3.connectionpool\").disabled = False\n\n    # Flip y-axis, because convention is x in positive direction and y in negative, but gee use positive for both\n    tile = tile.isel(y=slice(None, None, -1))\n\n    # For some reason xee does not always set the crs\n    tile = tile.odc.assign_crs(self.extent.crs)\n\n    # Recrop the data to the geobox_tile, since gee does not always return the exact extent\n    tile = tile.odc.crop(geobox_tile.item.extent)\n\n    # Save original min-max values for each band for clipping later\n    clip_values = {\n        band: (tile[band].min().values.item(), tile[band].max().values.item()) for band in tile.data_vars\n    }\n\n    # Interpolate missing values (there are very few, so we actually can interpolate them)\n    tile.rio.set_spatial_dims(x_dim=\"x\", y_dim=\"y\", inplace=True)\n    for band in tile.data_vars:\n        tile[band] = tile[band].rio.write_nodata(np.nan).rio.interpolate_na()\n\n    # Convert to uint8\n    for band in tile.data_vars:\n        band_min, band_max = clip_values[band]\n        tile[band] = tile[band].clip(band_min, band_max, keep_attrs=True).astype(\"uint8\").rio.write_nodata(None)\n\n    # Get the slice of the datacube where the tile will be written\n    logger.debug(\n        f\"{geobox_tile.id=}: {tile.sizes=} {tile.x[0].item()=} {tile.y[0].item()=}\"\n        f\" {zcube['x'][0]=} {zcube['y'][0]=}\"\n    )\n    target_slice = self.zgeobox.overlap_roi(tile.odc.geobox)\n\n    logger.debug(f\"tile.id={geobox_tile.id}: Writing to {target_slice=}\")\n\n    for channel in self.channels:\n        raw_data = tile[channel].values\n        zcube[channel][target_slice] = raw_data\n</code></pre>"},{"location":"reference/smart_geocubes/accessors/gee/#smart_geocubes.accessors.gee.GEEAccessor.download_tile(zcube)","title":"<code>zcube</code>","text":"(<code>Group</code>)           \u2013            <p>The zarr datacube to download the tile to.</p>"},{"location":"reference/smart_geocubes/accessors/gee/#smart_geocubes.accessors.gee.GEEAccessor.download_tile(geobox_tile)","title":"<code>geobox_tile</code>","text":"(<code>TileWrapper</code>)           \u2013            <p>The tile to download.</p>"},{"location":"reference/smart_geocubes/accessors/stac/","title":"smart_geocubes.accessors.stac","text":""},{"location":"reference/smart_geocubes/accessors/stac/#smart_geocubes.accessors.stac","title":"smart_geocubes.accessors.stac","text":"<p>STAC Accessor for Smart Geocubes.</p> <p>Classes:</p> <ul> <li> <code>STACAccessor</code>           \u2013            <p>Accessor for STAC data.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>correct_bounds</code>             \u2013              <p>Correct the bounds of a tile to fit within a GeoBox.</p> </li> </ul>"},{"location":"reference/smart_geocubes/accessors/stac/#smart_geocubes.accessors.stac.STACAccessor","title":"STACAccessor","text":"<pre><code>STACAccessor(\n    storage: Storage | Path | str,\n    create_icechunk_storage: bool = True,\n    title: str | None = None,\n    extent: GeoBox | None = None,\n    chunk_size: int | None = None,\n    channels: list | None = None,\n    channels_meta: dict | None = None,\n    channels_encoding: dict | None = None,\n)\n</code></pre> <p>               Bases: <code>RemoteAccessor</code></p> <p>Accessor for STAC data.</p> <p>Methods:</p> <ul> <li> <code>adjacent_tiles</code>             \u2013              <p>Get adjacent tiles from a STAC API.</p> </li> <li> <code>current_state</code>             \u2013              <p>Get info about currently stored tiles.</p> </li> <li> <code>download_tile</code>             \u2013              <p>Download a tile from a STAC API and write it to a zarr datacube.</p> </li> </ul> Source code in <code>src/smart_geocubes/accessors/base.py</code> <pre><code>def __init__(\n    self,\n    storage: icechunk.Storage | Path | str,\n    create_icechunk_storage: bool = True,\n    title: str | None = None,\n    extent: GeoBox | None = None,\n    chunk_size: int | None = None,\n    channels: list | None = None,\n    channels_meta: dict | None = None,\n    channels_encoding: dict | None = None,\n):\n    \"\"\"Initialize base class for remote accessors.\n\n    !!! warning\n\n        In a multiprocessing environment, it is strongly recommended to not set `create_icechunk_storage=False`.\n\n    The arguments `title`, `extent`, `chunk_size`, `channels`, `channels_meta` and `channels_encoding`\n    will overwrite the dataset defaults and are only considered for the creation of a new datacube.\n    It is strongly recommended to not set these values manually.\n\n    Args:\n        storage (icechunk.Storage): The icechunk storage of the datacube.\n        create_icechunk_storage (bool, optional): If an icechunk repository should be created at provided storage\n            if no exists.\n            This should be disabled in a multiprocessing environment.\n            Defaults to True.\n        title (str | None, optional): The title of the datacube. Defaults to None.\n        extent (GeoBox | None, optional): The extent of the datacube. Defaults to None.\n        chunk_size (int | None, optional): The chunk size of the datacube. Defaults to None.\n        channels (list | None, optional): The channels of the datacube. Defaults to None.\n        channels_meta (dict | None, optional): The channels meta of the datacube. Defaults to None.\n        channels_encoding (dict | None, optional): The channels encoding of the datacube. Defaults to None.\n\n    Raises:\n        ValueError: If the storage is not an icechunk.Storage.\n\n    \"\"\"\n    if isinstance(storage, (str | Path)):\n        storage = storage if isinstance(storage, str) else str(storage.resolve())\n        storage = icechunk.local_filesystem_storage(storage)\n    if not isinstance(storage, icechunk.Storage):\n        raise ValueError(f\"Expected an icechunk.Storage, but got {type(storage)}\")\n    self.storage = storage\n    logger.debug(f\"Using storage {storage=}\")\n    if create_icechunk_storage:\n        self.repo = icechunk.Repository.open_or_create(storage)  # Will create a \"main\" branch\n    else:\n        self.repo = icechunk.Repository.open(storage)\n    logger.debug(f\"Using repository {self.repo=}\")\n\n    # We overwrite optionally the dataset attributes with user defined settings\n    self.title = title or type(self).__name__\n    if extent is not None:\n        self.extent = extent\n    if chunk_size is not None:\n        self.chunk_size = chunk_size\n    if channels is not None:\n        self.channels = channels\n    if channels_meta is not None:\n        self.channels_meta\n    if channels_encoding is not None:\n        self.channels_encoding\n\n    # TODO: store the settings variables in metadata and validate here\n\n    # The benchmarking timer for this accessor\n    self.stopuhr = StopUhr(logger.debug)\n\n    # The TypeVar used by the ThreadingHandler was added in 3.12\n    # The Shutdown method of the queue was added in 3.13\n    # Hence, we don't want to import the module unless Python 3.13 is installed\n    if _check_python_version(3, 13):\n        from smart_geocubes.concurrency.threading import ThreadingHandler\n\n        self.threading_handler = ThreadingHandler(self._threading_download)\n</code></pre>"},{"location":"reference/smart_geocubes/accessors/stac/#smart_geocubes.accessors.stac.STACAccessor.adjacent_tiles","title":"adjacent_tiles","text":"<pre><code>adjacent_tiles(geobox: GeoBox) -&gt; list[TileWrapper]\n</code></pre> <p>Get adjacent tiles from a STAC API.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[TileWrapper]</code>           \u2013            <p>list[TileWrapper]: List of adjacent tiles, wrapped in own datastructure for easier processing.</p> </li> </ul> Source code in <code>src/smart_geocubes/accessors/stac.py</code> <pre><code>def adjacent_tiles(self, geobox: GeoBox) -&gt; list[TileWrapper]:\n    \"\"\"Get adjacent tiles from a STAC API.\n\n    Args:\n        geobox (GeoBox): The geobox for which to get adjacent tiles.\n\n    Returns:\n        list[TileWrapper]: List of adjacent tiles, wrapped in own datastructure for easier processing.\n\n    \"\"\"\n    import pystac_client\n\n    catalog = pystac_client.Client.open(self.stac_api_url)\n    search = catalog.search(collections=[self.collection], intersects=geobox.to_crs(\"EPSG:4326\").extent.geom)\n    items = list(search.items())\n    return [TileWrapper(item.id, item) for item in items]\n</code></pre>"},{"location":"reference/smart_geocubes/accessors/stac/#smart_geocubes.accessors.stac.STACAccessor.adjacent_tiles(geobox)","title":"<code>geobox</code>","text":"(<code>GeoBox</code>)           \u2013            <p>The geobox for which to get adjacent tiles.</p>"},{"location":"reference/smart_geocubes/accessors/stac/#smart_geocubes.accessors.stac.STACAccessor.current_state","title":"current_state","text":"<pre><code>current_state() -&gt; gpd.GeoDataFrame | None\n</code></pre> <p>Get info about currently stored tiles.</p> <p>Returns:</p> <ul> <li> <code>GeoDataFrame | None</code>           \u2013            <p>gpd.GeoDataFrame: Tile info from pystac. None if datacube is empty.</p> </li> </ul> Source code in <code>src/smart_geocubes/accessors/stac.py</code> <pre><code>def current_state(self) -&gt; gpd.GeoDataFrame | None:\n    \"\"\"Get info about currently stored tiles.\n\n    Returns:\n        gpd.GeoDataFrame: Tile info from pystac. None if datacube is empty.\n\n\n    \"\"\"\n    import geopandas as gpd\n    import pystac_client\n\n    if not self.created:\n        return None\n\n    session = self.repo.readonly_session(\"main\")\n    zcube = zarr.open(session.store, mode=\"r\")\n    loaded_tiles = zcube.attrs.get(\"loaded_tiles\", [])\n\n    if len(loaded_tiles) == 0:\n        return None\n\n    catalog = pystac_client.Client.open(self.stac_api_url)\n    search = catalog.search(collections=[self.collection], ids=loaded_tiles)\n    stac_json = search.item_collection_as_dict()\n\n    gdf = gpd.GeoDataFrame.from_features(stac_json, \"epsg:4326\")\n    return gdf\n</code></pre>"},{"location":"reference/smart_geocubes/accessors/stac/#smart_geocubes.accessors.stac.STACAccessor.download_tile","title":"download_tile","text":"<pre><code>download_tile(zcube: Group, stac_tile: TileWrapper)\n</code></pre> <p>Download a tile from a STAC API and write it to a zarr datacube.</p> <p>Parameters:</p> Source code in <code>src/smart_geocubes/accessors/stac.py</code> <pre><code>def download_tile(self, zcube: zarr.Group, stac_tile: TileWrapper):\n    \"\"\"Download a tile from a STAC API and write it to a zarr datacube.\n\n    Args:\n        zcube (zarr.Array): The zarr datacube to write the tile to.\n        stac_tile (TileWrapper): The tile to download and write.\n\n    \"\"\"\n    from odc.stac import stac_load\n\n    tile = stac_load([stac_tile.item], bands=self.channels, chunks=None, progress=None)\n\n    # TODO: Allow for multi-temporal datacubes\n    tile = tile.max(\"time\")\n\n    # Get the slice of the datacube where the tile will be written\n    logger.debug(\n        f\"{stac_tile.id=}: {tile.sizes=} {tile.x[0].item()=} {tile.y[0].item()=} {zcube['x'][0]=} {zcube['y'][0]=}\"\n    )\n    tile = correct_bounds(tile, self.zgeobox)\n    target_slice = self.zgeobox.overlap_roi(tile.odc.geobox)\n\n    logger.debug(f\"tile.id={stac_tile.id}: Writing to {target_slice=}\")\n\n    for channel in self.channels:\n        raw_data = tile[channel].values\n        # Sometimes the data downloaded from stac has nan-borders, which would overwrite existing data\n        # Replace these nan borders with existing data if there is any\n        raw_data = np.where(~np.isnan(raw_data), raw_data, zcube[channel][target_slice])\n        zcube[channel][target_slice] = raw_data\n</code></pre>"},{"location":"reference/smart_geocubes/accessors/stac/#smart_geocubes.accessors.stac.STACAccessor.download_tile(zcube)","title":"<code>zcube</code>","text":"(<code>Array</code>)           \u2013            <p>The zarr datacube to write the tile to.</p>"},{"location":"reference/smart_geocubes/accessors/stac/#smart_geocubes.accessors.stac.STACAccessor.download_tile(stac_tile)","title":"<code>stac_tile</code>","text":"(<code>TileWrapper</code>)           \u2013            <p>The tile to download and write.</p>"},{"location":"reference/smart_geocubes/accessors/stac/#smart_geocubes.accessors.stac.correct_bounds","title":"correct_bounds","text":"<pre><code>correct_bounds(\n    tile: Dataset, zgeobox: GeoBox\n) -&gt; xr.Dataset\n</code></pre> <p>Correct the bounds of a tile to fit within a GeoBox.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the tile is out of the geobox's bounds.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dataset</code>           \u2013            <p>xr.Dataset: The corrected tile.</p> </li> </ul> Source code in <code>src/smart_geocubes/accessors/stac.py</code> <pre><code>def correct_bounds(tile: xr.Dataset, zgeobox: GeoBox) -&gt; xr.Dataset:\n    \"\"\"Correct the bounds of a tile to fit within a GeoBox.\n\n    Args:\n        tile (xr.Dataset): The tile to correct.\n        zgeobox (GeoBox): The GeoBox to correct the tile to.\n\n    Raises:\n        ValueError: If the tile is out of the geobox's bounds.\n\n    Returns:\n        xr.Dataset: The corrected tile.\n\n    \"\"\"\n    yslice, xslice = tile.odc.geobox.overlap_roi(zgeobox)\n    yslice_is_valid = yslice.start &gt;= 0 and yslice.start &lt; yslice.stop and yslice.stop &lt;= tile.sizes[\"y\"]\n    xslice_is_valid = xslice.start &gt;= 0 and xslice.start &lt; xslice.stop and xslice.stop &lt;= tile.sizes[\"x\"]\n    if not yslice_is_valid or not xslice_is_valid:\n        logger.error(f\"Tile is out of bounds! {yslice=} {xslice=} {tile.sizes=} {zgeobox=}\")\n        raise ValueError(\"Tile is out of bounds!\")\n    if yslice.start != 0 or xslice.start != 0 or yslice.stop != tile.sizes[\"y\"] or xslice.stop != tile.sizes[\"x\"]:\n        logger.warning(\n            f\"Correcting tile bounds. This is an indicator that the datacube extent is to narrow.\"\n            f\" This will crop the tile to fit the datacube. {yslice=} {xslice=} {tile.sizes=} {zgeobox=}\"\n        )\n        tile = tile.isel(x=xslice, y=yslice)\n    return tile\n</code></pre>"},{"location":"reference/smart_geocubes/accessors/stac/#smart_geocubes.accessors.stac.correct_bounds(tile)","title":"<code>tile</code>","text":"(<code>Dataset</code>)           \u2013            <p>The tile to correct.</p>"},{"location":"reference/smart_geocubes/accessors/stac/#smart_geocubes.accessors.stac.correct_bounds(zgeobox)","title":"<code>zgeobox</code>","text":"(<code>GeoBox</code>)           \u2013            <p>The GeoBox to correct the tile to.</p>"},{"location":"reference/smart_geocubes/concurrency/","title":"smart_geocubes.concurrency","text":""},{"location":"reference/smart_geocubes/concurrency/#smart_geocubes.concurrency","title":"smart_geocubes.concurrency","text":"<p>Concurrency support for remote accessors.</p> <p>Modules:</p> <ul> <li> <code>threading</code>           \u2013            <p>Threading download for remote accessors.</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>AlreadyDownloadedError</code>           \u2013            <p>Exception to raise when a tile is already downloaded.</p> </li> </ul>"},{"location":"reference/smart_geocubes/concurrency/#smart_geocubes.concurrency.AlreadyDownloadedError","title":"AlreadyDownloadedError","text":"<p>               Bases: <code>Exception</code></p> <p>Exception to raise when a tile is already downloaded.</p>"},{"location":"reference/smart_geocubes/concurrency/threading/","title":"smart_geocubes.concurrency.threading","text":""},{"location":"reference/smart_geocubes/concurrency/threading/#smart_geocubes.concurrency.threading","title":"smart_geocubes.concurrency.threading","text":"<p>Threading download for remote accessors.</p> <p>Classes:</p> <ul> <li> <code>SetQueue</code>           \u2013            <p>Set-like queue.</p> </li> <li> <code>ThreadingHandler</code>           \u2013            <p>A threading handler for downloading tiles.</p> </li> </ul>"},{"location":"reference/smart_geocubes/concurrency/threading/#smart_geocubes.concurrency.threading.SetQueue","title":"SetQueue","text":"<p>               Bases: <code>Queue</code></p> <p>Set-like queue.</p> <p>Actually uses a list which checks for duplicates before adding an item.</p>"},{"location":"reference/smart_geocubes/concurrency/threading/#smart_geocubes.concurrency.threading.ThreadingHandler","title":"ThreadingHandler","text":"<pre><code>ThreadingHandler(f: Callable[[T], None])\n</code></pre> <p>A threading handler for downloading tiles.</p> <p>Create a new threading handler.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>start</code>             \u2013              <p>Start the download thread, if not exists yet.</p> </li> <li> <code>stop</code>             \u2013              <p>Stop the download thread.</p> </li> </ul> Source code in <code>src/smart_geocubes/concurrency/threading.py</code> <pre><code>def __init__(self, f: Callable[[T], None]):\n    \"\"\"Create a new threading handler.\n\n    Args:\n        f (Callable[[T], None]): The function to call for each tile.\n\n    \"\"\"\n    self._lock = threading.Lock()\n    self._queue: SetQueue[T] = SetQueue()\n    self._dthread: threading.Thread | None = None\n    self.f = f\n</code></pre>"},{"location":"reference/smart_geocubes/concurrency/threading/#smart_geocubes.concurrency.threading.ThreadingHandler(f)","title":"<code>f</code>","text":"(<code>Callable[[T], None]</code>)           \u2013            <p>The function to call for each tile.</p>"},{"location":"reference/smart_geocubes/concurrency/threading/#smart_geocubes.concurrency.threading.ThreadingHandler.start","title":"start","text":"<pre><code>start()\n</code></pre> <p>Start the download thread, if not exists yet.</p> Source code in <code>src/smart_geocubes/concurrency/threading.py</code> <pre><code>def start(self):\n    \"\"\"Start the download thread, if not exists yet.\"\"\"\n    with self._lock:\n        if self._dthread is None:\n            self._dthread = threading.Thread(\n                target=_threading_download_loop, daemon=True, args=(self.f, self._queue)\n            )\n            self._dthread.start()\n</code></pre>"},{"location":"reference/smart_geocubes/concurrency/threading/#smart_geocubes.concurrency.threading.ThreadingHandler.stop","title":"stop","text":"<pre><code>stop()\n</code></pre> <p>Stop the download thread.</p> Source code in <code>src/smart_geocubes/concurrency/threading.py</code> <pre><code>def stop(self):\n    \"\"\"Stop the download thread.\"\"\"\n    with self._lock:\n        if self._queue.empty():\n            self._queue.shutdown(immediate=True)\n            if self._dthread is not None:\n                self._dthread.join()\n                self._dthread = None\n            self._queue = SetQueue()\n</code></pre>"},{"location":"reference/smart_geocubes/datasets/","title":"smart_geocubes.datasets","text":""},{"location":"reference/smart_geocubes/datasets/#smart_geocubes.datasets","title":"smart_geocubes.datasets","text":"<p>Predefined datasets for the SmartGeocubes package.</p> <p>Modules:</p> <ul> <li> <code>arcticdem</code>           \u2013            <p>Predefined accessor for ArcticDEM 32m, 10m and 2m data.</p> </li> <li> <code>tctrend</code>           \u2013            <p>Predefined accessor for TCTrend data.</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>ArcticDEM10m</code>           \u2013            <p>Accessor for ArcticDEM 10m data.</p> </li> <li> <code>ArcticDEM2m</code>           \u2013            <p>Accessor for ArcticDEM 2m data.</p> </li> <li> <code>ArcticDEM32m</code>           \u2013            <p>Accessor for ArcticDEM 32m data.</p> </li> <li> <code>TCTrend</code>           \u2013            <p>Accessor for TCTrend data.</p> </li> </ul>"},{"location":"reference/smart_geocubes/datasets/#smart_geocubes.datasets.ArcticDEM10m","title":"ArcticDEM10m","text":"<pre><code>ArcticDEM10m(\n    storage: Storage | Path | str,\n    create_icechunk_storage: bool = True,\n    title: str | None = None,\n    extent: GeoBox | None = None,\n    chunk_size: int | None = None,\n    channels: list | None = None,\n    channels_meta: dict | None = None,\n    channels_encoding: dict | None = None,\n)\n</code></pre> <p>               Bases: <code>ArcticDEMABC</code></p> <p>Accessor for ArcticDEM 10m data.</p> Source code in <code>src/smart_geocubes/accessors/base.py</code> <pre><code>def __init__(\n    self,\n    storage: icechunk.Storage | Path | str,\n    create_icechunk_storage: bool = True,\n    title: str | None = None,\n    extent: GeoBox | None = None,\n    chunk_size: int | None = None,\n    channels: list | None = None,\n    channels_meta: dict | None = None,\n    channels_encoding: dict | None = None,\n):\n    \"\"\"Initialize base class for remote accessors.\n\n    !!! warning\n\n        In a multiprocessing environment, it is strongly recommended to not set `create_icechunk_storage=False`.\n\n    The arguments `title`, `extent`, `chunk_size`, `channels`, `channels_meta` and `channels_encoding`\n    will overwrite the dataset defaults and are only considered for the creation of a new datacube.\n    It is strongly recommended to not set these values manually.\n\n    Args:\n        storage (icechunk.Storage): The icechunk storage of the datacube.\n        create_icechunk_storage (bool, optional): If an icechunk repository should be created at provided storage\n            if no exists.\n            This should be disabled in a multiprocessing environment.\n            Defaults to True.\n        title (str | None, optional): The title of the datacube. Defaults to None.\n        extent (GeoBox | None, optional): The extent of the datacube. Defaults to None.\n        chunk_size (int | None, optional): The chunk size of the datacube. Defaults to None.\n        channels (list | None, optional): The channels of the datacube. Defaults to None.\n        channels_meta (dict | None, optional): The channels meta of the datacube. Defaults to None.\n        channels_encoding (dict | None, optional): The channels encoding of the datacube. Defaults to None.\n\n    Raises:\n        ValueError: If the storage is not an icechunk.Storage.\n\n    \"\"\"\n    if isinstance(storage, (str | Path)):\n        storage = storage if isinstance(storage, str) else str(storage.resolve())\n        storage = icechunk.local_filesystem_storage(storage)\n    if not isinstance(storage, icechunk.Storage):\n        raise ValueError(f\"Expected an icechunk.Storage, but got {type(storage)}\")\n    self.storage = storage\n    logger.debug(f\"Using storage {storage=}\")\n    if create_icechunk_storage:\n        self.repo = icechunk.Repository.open_or_create(storage)  # Will create a \"main\" branch\n    else:\n        self.repo = icechunk.Repository.open(storage)\n    logger.debug(f\"Using repository {self.repo=}\")\n\n    # We overwrite optionally the dataset attributes with user defined settings\n    self.title = title or type(self).__name__\n    if extent is not None:\n        self.extent = extent\n    if chunk_size is not None:\n        self.chunk_size = chunk_size\n    if channels is not None:\n        self.channels = channels\n    if channels_meta is not None:\n        self.channels_meta\n    if channels_encoding is not None:\n        self.channels_encoding\n\n    # TODO: store the settings variables in metadata and validate here\n\n    # The benchmarking timer for this accessor\n    self.stopuhr = StopUhr(logger.debug)\n\n    # The TypeVar used by the ThreadingHandler was added in 3.12\n    # The Shutdown method of the queue was added in 3.13\n    # Hence, we don't want to import the module unless Python 3.13 is installed\n    if _check_python_version(3, 13):\n        from smart_geocubes.concurrency.threading import ThreadingHandler\n\n        self.threading_handler = ThreadingHandler(self._threading_download)\n</code></pre>"},{"location":"reference/smart_geocubes/datasets/#smart_geocubes.datasets.ArcticDEM2m","title":"ArcticDEM2m","text":"<pre><code>ArcticDEM2m(\n    storage: Storage | Path | str,\n    create_icechunk_storage: bool = True,\n    title: str | None = None,\n    extent: GeoBox | None = None,\n    chunk_size: int | None = None,\n    channels: list | None = None,\n    channels_meta: dict | None = None,\n    channels_encoding: dict | None = None,\n)\n</code></pre> <p>               Bases: <code>ArcticDEMABC</code></p> <p>Accessor for ArcticDEM 2m data.</p> Source code in <code>src/smart_geocubes/accessors/base.py</code> <pre><code>def __init__(\n    self,\n    storage: icechunk.Storage | Path | str,\n    create_icechunk_storage: bool = True,\n    title: str | None = None,\n    extent: GeoBox | None = None,\n    chunk_size: int | None = None,\n    channels: list | None = None,\n    channels_meta: dict | None = None,\n    channels_encoding: dict | None = None,\n):\n    \"\"\"Initialize base class for remote accessors.\n\n    !!! warning\n\n        In a multiprocessing environment, it is strongly recommended to not set `create_icechunk_storage=False`.\n\n    The arguments `title`, `extent`, `chunk_size`, `channels`, `channels_meta` and `channels_encoding`\n    will overwrite the dataset defaults and are only considered for the creation of a new datacube.\n    It is strongly recommended to not set these values manually.\n\n    Args:\n        storage (icechunk.Storage): The icechunk storage of the datacube.\n        create_icechunk_storage (bool, optional): If an icechunk repository should be created at provided storage\n            if no exists.\n            This should be disabled in a multiprocessing environment.\n            Defaults to True.\n        title (str | None, optional): The title of the datacube. Defaults to None.\n        extent (GeoBox | None, optional): The extent of the datacube. Defaults to None.\n        chunk_size (int | None, optional): The chunk size of the datacube. Defaults to None.\n        channels (list | None, optional): The channels of the datacube. Defaults to None.\n        channels_meta (dict | None, optional): The channels meta of the datacube. Defaults to None.\n        channels_encoding (dict | None, optional): The channels encoding of the datacube. Defaults to None.\n\n    Raises:\n        ValueError: If the storage is not an icechunk.Storage.\n\n    \"\"\"\n    if isinstance(storage, (str | Path)):\n        storage = storage if isinstance(storage, str) else str(storage.resolve())\n        storage = icechunk.local_filesystem_storage(storage)\n    if not isinstance(storage, icechunk.Storage):\n        raise ValueError(f\"Expected an icechunk.Storage, but got {type(storage)}\")\n    self.storage = storage\n    logger.debug(f\"Using storage {storage=}\")\n    if create_icechunk_storage:\n        self.repo = icechunk.Repository.open_or_create(storage)  # Will create a \"main\" branch\n    else:\n        self.repo = icechunk.Repository.open(storage)\n    logger.debug(f\"Using repository {self.repo=}\")\n\n    # We overwrite optionally the dataset attributes with user defined settings\n    self.title = title or type(self).__name__\n    if extent is not None:\n        self.extent = extent\n    if chunk_size is not None:\n        self.chunk_size = chunk_size\n    if channels is not None:\n        self.channels = channels\n    if channels_meta is not None:\n        self.channels_meta\n    if channels_encoding is not None:\n        self.channels_encoding\n\n    # TODO: store the settings variables in metadata and validate here\n\n    # The benchmarking timer for this accessor\n    self.stopuhr = StopUhr(logger.debug)\n\n    # The TypeVar used by the ThreadingHandler was added in 3.12\n    # The Shutdown method of the queue was added in 3.13\n    # Hence, we don't want to import the module unless Python 3.13 is installed\n    if _check_python_version(3, 13):\n        from smart_geocubes.concurrency.threading import ThreadingHandler\n\n        self.threading_handler = ThreadingHandler(self._threading_download)\n</code></pre>"},{"location":"reference/smart_geocubes/datasets/#smart_geocubes.datasets.ArcticDEM32m","title":"ArcticDEM32m","text":"<pre><code>ArcticDEM32m(\n    storage: Storage | Path | str,\n    create_icechunk_storage: bool = True,\n    title: str | None = None,\n    extent: GeoBox | None = None,\n    chunk_size: int | None = None,\n    channels: list | None = None,\n    channels_meta: dict | None = None,\n    channels_encoding: dict | None = None,\n)\n</code></pre> <p>               Bases: <code>ArcticDEMABC</code></p> <p>Accessor for ArcticDEM 32m data.</p> Source code in <code>src/smart_geocubes/accessors/base.py</code> <pre><code>def __init__(\n    self,\n    storage: icechunk.Storage | Path | str,\n    create_icechunk_storage: bool = True,\n    title: str | None = None,\n    extent: GeoBox | None = None,\n    chunk_size: int | None = None,\n    channels: list | None = None,\n    channels_meta: dict | None = None,\n    channels_encoding: dict | None = None,\n):\n    \"\"\"Initialize base class for remote accessors.\n\n    !!! warning\n\n        In a multiprocessing environment, it is strongly recommended to not set `create_icechunk_storage=False`.\n\n    The arguments `title`, `extent`, `chunk_size`, `channels`, `channels_meta` and `channels_encoding`\n    will overwrite the dataset defaults and are only considered for the creation of a new datacube.\n    It is strongly recommended to not set these values manually.\n\n    Args:\n        storage (icechunk.Storage): The icechunk storage of the datacube.\n        create_icechunk_storage (bool, optional): If an icechunk repository should be created at provided storage\n            if no exists.\n            This should be disabled in a multiprocessing environment.\n            Defaults to True.\n        title (str | None, optional): The title of the datacube. Defaults to None.\n        extent (GeoBox | None, optional): The extent of the datacube. Defaults to None.\n        chunk_size (int | None, optional): The chunk size of the datacube. Defaults to None.\n        channels (list | None, optional): The channels of the datacube. Defaults to None.\n        channels_meta (dict | None, optional): The channels meta of the datacube. Defaults to None.\n        channels_encoding (dict | None, optional): The channels encoding of the datacube. Defaults to None.\n\n    Raises:\n        ValueError: If the storage is not an icechunk.Storage.\n\n    \"\"\"\n    if isinstance(storage, (str | Path)):\n        storage = storage if isinstance(storage, str) else str(storage.resolve())\n        storage = icechunk.local_filesystem_storage(storage)\n    if not isinstance(storage, icechunk.Storage):\n        raise ValueError(f\"Expected an icechunk.Storage, but got {type(storage)}\")\n    self.storage = storage\n    logger.debug(f\"Using storage {storage=}\")\n    if create_icechunk_storage:\n        self.repo = icechunk.Repository.open_or_create(storage)  # Will create a \"main\" branch\n    else:\n        self.repo = icechunk.Repository.open(storage)\n    logger.debug(f\"Using repository {self.repo=}\")\n\n    # We overwrite optionally the dataset attributes with user defined settings\n    self.title = title or type(self).__name__\n    if extent is not None:\n        self.extent = extent\n    if chunk_size is not None:\n        self.chunk_size = chunk_size\n    if channels is not None:\n        self.channels = channels\n    if channels_meta is not None:\n        self.channels_meta\n    if channels_encoding is not None:\n        self.channels_encoding\n\n    # TODO: store the settings variables in metadata and validate here\n\n    # The benchmarking timer for this accessor\n    self.stopuhr = StopUhr(logger.debug)\n\n    # The TypeVar used by the ThreadingHandler was added in 3.12\n    # The Shutdown method of the queue was added in 3.13\n    # Hence, we don't want to import the module unless Python 3.13 is installed\n    if _check_python_version(3, 13):\n        from smart_geocubes.concurrency.threading import ThreadingHandler\n\n        self.threading_handler = ThreadingHandler(self._threading_download)\n</code></pre>"},{"location":"reference/smart_geocubes/datasets/#smart_geocubes.datasets.TCTrend","title":"TCTrend","text":"<pre><code>TCTrend(\n    storage: Storage | Path | str,\n    create_icechunk_storage: bool = True,\n    title: str | None = None,\n    extent: GeoBox | None = None,\n    chunk_size: int | None = None,\n    channels: list | None = None,\n    channels_meta: dict | None = None,\n    channels_encoding: dict | None = None,\n)\n</code></pre> <p>               Bases: <code>GEEAccessor</code></p> <p>Accessor for TCTrend data.</p> <p>Methods:</p> <ul> <li> <code>visualize_state</code>             \u2013              <p>Visulize the extend, hence the already downloaded and filled data, of the datacube.</p> </li> </ul> Source code in <code>src/smart_geocubes/accessors/base.py</code> <pre><code>def __init__(\n    self,\n    storage: icechunk.Storage | Path | str,\n    create_icechunk_storage: bool = True,\n    title: str | None = None,\n    extent: GeoBox | None = None,\n    chunk_size: int | None = None,\n    channels: list | None = None,\n    channels_meta: dict | None = None,\n    channels_encoding: dict | None = None,\n):\n    \"\"\"Initialize base class for remote accessors.\n\n    !!! warning\n\n        In a multiprocessing environment, it is strongly recommended to not set `create_icechunk_storage=False`.\n\n    The arguments `title`, `extent`, `chunk_size`, `channels`, `channels_meta` and `channels_encoding`\n    will overwrite the dataset defaults and are only considered for the creation of a new datacube.\n    It is strongly recommended to not set these values manually.\n\n    Args:\n        storage (icechunk.Storage): The icechunk storage of the datacube.\n        create_icechunk_storage (bool, optional): If an icechunk repository should be created at provided storage\n            if no exists.\n            This should be disabled in a multiprocessing environment.\n            Defaults to True.\n        title (str | None, optional): The title of the datacube. Defaults to None.\n        extent (GeoBox | None, optional): The extent of the datacube. Defaults to None.\n        chunk_size (int | None, optional): The chunk size of the datacube. Defaults to None.\n        channels (list | None, optional): The channels of the datacube. Defaults to None.\n        channels_meta (dict | None, optional): The channels meta of the datacube. Defaults to None.\n        channels_encoding (dict | None, optional): The channels encoding of the datacube. Defaults to None.\n\n    Raises:\n        ValueError: If the storage is not an icechunk.Storage.\n\n    \"\"\"\n    if isinstance(storage, (str | Path)):\n        storage = storage if isinstance(storage, str) else str(storage.resolve())\n        storage = icechunk.local_filesystem_storage(storage)\n    if not isinstance(storage, icechunk.Storage):\n        raise ValueError(f\"Expected an icechunk.Storage, but got {type(storage)}\")\n    self.storage = storage\n    logger.debug(f\"Using storage {storage=}\")\n    if create_icechunk_storage:\n        self.repo = icechunk.Repository.open_or_create(storage)  # Will create a \"main\" branch\n    else:\n        self.repo = icechunk.Repository.open(storage)\n    logger.debug(f\"Using repository {self.repo=}\")\n\n    # We overwrite optionally the dataset attributes with user defined settings\n    self.title = title or type(self).__name__\n    if extent is not None:\n        self.extent = extent\n    if chunk_size is not None:\n        self.chunk_size = chunk_size\n    if channels is not None:\n        self.channels = channels\n    if channels_meta is not None:\n        self.channels_meta\n    if channels_encoding is not None:\n        self.channels_encoding\n\n    # TODO: store the settings variables in metadata and validate here\n\n    # The benchmarking timer for this accessor\n    self.stopuhr = StopUhr(logger.debug)\n\n    # The TypeVar used by the ThreadingHandler was added in 3.12\n    # The Shutdown method of the queue was added in 3.13\n    # Hence, we don't want to import the module unless Python 3.13 is installed\n    if _check_python_version(3, 13):\n        from smart_geocubes.concurrency.threading import ThreadingHandler\n\n        self.threading_handler = ThreadingHandler(self._threading_download)\n</code></pre>"},{"location":"reference/smart_geocubes/datasets/#smart_geocubes.datasets.TCTrend.visualize_state","title":"visualize_state","text":"<pre><code>visualize_state(\n    ax: Axes | None = None,\n) -&gt; plt.Figure | plt.Axes\n</code></pre> <p>Visulize the extend, hence the already downloaded and filled data, of the datacube.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Figure | Axes</code>           \u2013            <p>plt.Figure | plt.Axes: The figure with the visualization if no axes was provided, else the axes.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the datacube is empty</p> </li> </ul> Source code in <code>src/smart_geocubes/datasets/tctrend.py</code> <pre><code>def visualize_state(self, ax: \"plt.Axes | None\" = None) -&gt; \"plt.Figure | plt.Axes\":\n    \"\"\"Visulize the extend, hence the already downloaded and filled data, of the datacube.\n\n    Args:\n        ax (plt.Axes | None): The axes drawn to. If None, will create a new figure and axes.\n\n    Returns:\n        plt.Figure | plt.Axes: The figure with the visualization if no axes was provided, else the axes.\n\n    Raises:\n        ValueError: If the datacube is empty\n\n    \"\"\"\n    import cartopy.crs as ccrs\n    import cartopy.feature as cfeature\n    import matplotlib.pyplot as plt\n\n    tile_info = self.current_state()\n\n    if tile_info is None:\n        raise ValueError(\"Datacube is not created or loaded yet. Can't visualize!\")\n\n    # Define the projection\n    projection = ccrs.PlateCarree()\n\n    # Create a figure\n    fig = None\n    if ax is None:\n        fig, ax = plt.subplots(figsize=(10, 10), subplot_kw={\"projection\": projection})\n\n    # Set the extent to show the whole world\n    ax.set_extent([-180, 180, -90, 90], crs=ccrs.PlateCarree())\n\n    # Add features\n    ax.add_feature(cfeature.LAND, zorder=0, edgecolor=\"black\", facecolor=\"white\")\n    ax.add_feature(cfeature.OCEAN, zorder=0, facecolor=\"lightgrey\")\n    ax.add_feature(cfeature.COASTLINE)\n    ax.add_feature(cfeature.BORDERS, linestyle=\":\")\n    ax.add_feature(cfeature.LAKES, alpha=0.5)\n    ax.add_feature(cfeature.RIVERS)\n\n    # Add gridlines\n    gl = ax.gridlines(draw_labels=True)\n    gl.top_labels = False\n    gl.right_labels = False\n\n    tile_info.plot(\n        \"id\",\n        ax=ax,\n        transform=ccrs.PlateCarree(),\n        edgecolor=\"black\",\n        categorical=True,\n        aspect=\"equal\",\n        alpha=0.5,\n    )\n\n    if fig is not None:\n        return fig\n    else:\n        return ax\n</code></pre>"},{"location":"reference/smart_geocubes/datasets/#smart_geocubes.datasets.TCTrend.visualize_state(ax)","title":"<code>ax</code>","text":"(<code>Axes | None</code>, default:                   <code>None</code> )           \u2013            <p>The axes drawn to. If None, will create a new figure and axes.</p>"},{"location":"reference/smart_geocubes/datasets/arcticdem/","title":"smart_geocubes.datasets.arcticdem","text":""},{"location":"reference/smart_geocubes/datasets/arcticdem/#smart_geocubes.datasets.arcticdem","title":"smart_geocubes.datasets.arcticdem","text":"<p>Predefined accessor for ArcticDEM 32m, 10m and 2m data.</p> <p>Classes:</p> <ul> <li> <code>ArcticDEM10m</code>           \u2013            <p>Accessor for ArcticDEM 10m data.</p> </li> <li> <code>ArcticDEM2m</code>           \u2013            <p>Accessor for ArcticDEM 2m data.</p> </li> <li> <code>ArcticDEM32m</code>           \u2013            <p>Accessor for ArcticDEM 32m data.</p> </li> <li> <code>ArcticDEMABC</code>           \u2013            <p>ABC for Arcticdem data.</p> </li> <li> <code>LazyStacTileWrapper</code>           \u2013            <p>Lazy wrapper for a TileWrapper containing a STAC Item.</p> </li> </ul>"},{"location":"reference/smart_geocubes/datasets/arcticdem/#smart_geocubes.datasets.arcticdem.ArcticDEM10m","title":"ArcticDEM10m","text":"<pre><code>ArcticDEM10m(\n    storage: Storage | Path | str,\n    create_icechunk_storage: bool = True,\n    title: str | None = None,\n    extent: GeoBox | None = None,\n    chunk_size: int | None = None,\n    channels: list | None = None,\n    channels_meta: dict | None = None,\n    channels_encoding: dict | None = None,\n)\n</code></pre> <p>               Bases: <code>ArcticDEMABC</code></p> <p>Accessor for ArcticDEM 10m data.</p> Source code in <code>src/smart_geocubes/accessors/base.py</code> <pre><code>def __init__(\n    self,\n    storage: icechunk.Storage | Path | str,\n    create_icechunk_storage: bool = True,\n    title: str | None = None,\n    extent: GeoBox | None = None,\n    chunk_size: int | None = None,\n    channels: list | None = None,\n    channels_meta: dict | None = None,\n    channels_encoding: dict | None = None,\n):\n    \"\"\"Initialize base class for remote accessors.\n\n    !!! warning\n\n        In a multiprocessing environment, it is strongly recommended to not set `create_icechunk_storage=False`.\n\n    The arguments `title`, `extent`, `chunk_size`, `channels`, `channels_meta` and `channels_encoding`\n    will overwrite the dataset defaults and are only considered for the creation of a new datacube.\n    It is strongly recommended to not set these values manually.\n\n    Args:\n        storage (icechunk.Storage): The icechunk storage of the datacube.\n        create_icechunk_storage (bool, optional): If an icechunk repository should be created at provided storage\n            if no exists.\n            This should be disabled in a multiprocessing environment.\n            Defaults to True.\n        title (str | None, optional): The title of the datacube. Defaults to None.\n        extent (GeoBox | None, optional): The extent of the datacube. Defaults to None.\n        chunk_size (int | None, optional): The chunk size of the datacube. Defaults to None.\n        channels (list | None, optional): The channels of the datacube. Defaults to None.\n        channels_meta (dict | None, optional): The channels meta of the datacube. Defaults to None.\n        channels_encoding (dict | None, optional): The channels encoding of the datacube. Defaults to None.\n\n    Raises:\n        ValueError: If the storage is not an icechunk.Storage.\n\n    \"\"\"\n    if isinstance(storage, (str | Path)):\n        storage = storage if isinstance(storage, str) else str(storage.resolve())\n        storage = icechunk.local_filesystem_storage(storage)\n    if not isinstance(storage, icechunk.Storage):\n        raise ValueError(f\"Expected an icechunk.Storage, but got {type(storage)}\")\n    self.storage = storage\n    logger.debug(f\"Using storage {storage=}\")\n    if create_icechunk_storage:\n        self.repo = icechunk.Repository.open_or_create(storage)  # Will create a \"main\" branch\n    else:\n        self.repo = icechunk.Repository.open(storage)\n    logger.debug(f\"Using repository {self.repo=}\")\n\n    # We overwrite optionally the dataset attributes with user defined settings\n    self.title = title or type(self).__name__\n    if extent is not None:\n        self.extent = extent\n    if chunk_size is not None:\n        self.chunk_size = chunk_size\n    if channels is not None:\n        self.channels = channels\n    if channels_meta is not None:\n        self.channels_meta\n    if channels_encoding is not None:\n        self.channels_encoding\n\n    # TODO: store the settings variables in metadata and validate here\n\n    # The benchmarking timer for this accessor\n    self.stopuhr = StopUhr(logger.debug)\n\n    # The TypeVar used by the ThreadingHandler was added in 3.12\n    # The Shutdown method of the queue was added in 3.13\n    # Hence, we don't want to import the module unless Python 3.13 is installed\n    if _check_python_version(3, 13):\n        from smart_geocubes.concurrency.threading import ThreadingHandler\n\n        self.threading_handler = ThreadingHandler(self._threading_download)\n</code></pre>"},{"location":"reference/smart_geocubes/datasets/arcticdem/#smart_geocubes.datasets.arcticdem.ArcticDEM2m","title":"ArcticDEM2m","text":"<pre><code>ArcticDEM2m(\n    storage: Storage | Path | str,\n    create_icechunk_storage: bool = True,\n    title: str | None = None,\n    extent: GeoBox | None = None,\n    chunk_size: int | None = None,\n    channels: list | None = None,\n    channels_meta: dict | None = None,\n    channels_encoding: dict | None = None,\n)\n</code></pre> <p>               Bases: <code>ArcticDEMABC</code></p> <p>Accessor for ArcticDEM 2m data.</p> Source code in <code>src/smart_geocubes/accessors/base.py</code> <pre><code>def __init__(\n    self,\n    storage: icechunk.Storage | Path | str,\n    create_icechunk_storage: bool = True,\n    title: str | None = None,\n    extent: GeoBox | None = None,\n    chunk_size: int | None = None,\n    channels: list | None = None,\n    channels_meta: dict | None = None,\n    channels_encoding: dict | None = None,\n):\n    \"\"\"Initialize base class for remote accessors.\n\n    !!! warning\n\n        In a multiprocessing environment, it is strongly recommended to not set `create_icechunk_storage=False`.\n\n    The arguments `title`, `extent`, `chunk_size`, `channels`, `channels_meta` and `channels_encoding`\n    will overwrite the dataset defaults and are only considered for the creation of a new datacube.\n    It is strongly recommended to not set these values manually.\n\n    Args:\n        storage (icechunk.Storage): The icechunk storage of the datacube.\n        create_icechunk_storage (bool, optional): If an icechunk repository should be created at provided storage\n            if no exists.\n            This should be disabled in a multiprocessing environment.\n            Defaults to True.\n        title (str | None, optional): The title of the datacube. Defaults to None.\n        extent (GeoBox | None, optional): The extent of the datacube. Defaults to None.\n        chunk_size (int | None, optional): The chunk size of the datacube. Defaults to None.\n        channels (list | None, optional): The channels of the datacube. Defaults to None.\n        channels_meta (dict | None, optional): The channels meta of the datacube. Defaults to None.\n        channels_encoding (dict | None, optional): The channels encoding of the datacube. Defaults to None.\n\n    Raises:\n        ValueError: If the storage is not an icechunk.Storage.\n\n    \"\"\"\n    if isinstance(storage, (str | Path)):\n        storage = storage if isinstance(storage, str) else str(storage.resolve())\n        storage = icechunk.local_filesystem_storage(storage)\n    if not isinstance(storage, icechunk.Storage):\n        raise ValueError(f\"Expected an icechunk.Storage, but got {type(storage)}\")\n    self.storage = storage\n    logger.debug(f\"Using storage {storage=}\")\n    if create_icechunk_storage:\n        self.repo = icechunk.Repository.open_or_create(storage)  # Will create a \"main\" branch\n    else:\n        self.repo = icechunk.Repository.open(storage)\n    logger.debug(f\"Using repository {self.repo=}\")\n\n    # We overwrite optionally the dataset attributes with user defined settings\n    self.title = title or type(self).__name__\n    if extent is not None:\n        self.extent = extent\n    if chunk_size is not None:\n        self.chunk_size = chunk_size\n    if channels is not None:\n        self.channels = channels\n    if channels_meta is not None:\n        self.channels_meta\n    if channels_encoding is not None:\n        self.channels_encoding\n\n    # TODO: store the settings variables in metadata and validate here\n\n    # The benchmarking timer for this accessor\n    self.stopuhr = StopUhr(logger.debug)\n\n    # The TypeVar used by the ThreadingHandler was added in 3.12\n    # The Shutdown method of the queue was added in 3.13\n    # Hence, we don't want to import the module unless Python 3.13 is installed\n    if _check_python_version(3, 13):\n        from smart_geocubes.concurrency.threading import ThreadingHandler\n\n        self.threading_handler = ThreadingHandler(self._threading_download)\n</code></pre>"},{"location":"reference/smart_geocubes/datasets/arcticdem/#smart_geocubes.datasets.arcticdem.ArcticDEM32m","title":"ArcticDEM32m","text":"<pre><code>ArcticDEM32m(\n    storage: Storage | Path | str,\n    create_icechunk_storage: bool = True,\n    title: str | None = None,\n    extent: GeoBox | None = None,\n    chunk_size: int | None = None,\n    channels: list | None = None,\n    channels_meta: dict | None = None,\n    channels_encoding: dict | None = None,\n)\n</code></pre> <p>               Bases: <code>ArcticDEMABC</code></p> <p>Accessor for ArcticDEM 32m data.</p> Source code in <code>src/smart_geocubes/accessors/base.py</code> <pre><code>def __init__(\n    self,\n    storage: icechunk.Storage | Path | str,\n    create_icechunk_storage: bool = True,\n    title: str | None = None,\n    extent: GeoBox | None = None,\n    chunk_size: int | None = None,\n    channels: list | None = None,\n    channels_meta: dict | None = None,\n    channels_encoding: dict | None = None,\n):\n    \"\"\"Initialize base class for remote accessors.\n\n    !!! warning\n\n        In a multiprocessing environment, it is strongly recommended to not set `create_icechunk_storage=False`.\n\n    The arguments `title`, `extent`, `chunk_size`, `channels`, `channels_meta` and `channels_encoding`\n    will overwrite the dataset defaults and are only considered for the creation of a new datacube.\n    It is strongly recommended to not set these values manually.\n\n    Args:\n        storage (icechunk.Storage): The icechunk storage of the datacube.\n        create_icechunk_storage (bool, optional): If an icechunk repository should be created at provided storage\n            if no exists.\n            This should be disabled in a multiprocessing environment.\n            Defaults to True.\n        title (str | None, optional): The title of the datacube. Defaults to None.\n        extent (GeoBox | None, optional): The extent of the datacube. Defaults to None.\n        chunk_size (int | None, optional): The chunk size of the datacube. Defaults to None.\n        channels (list | None, optional): The channels of the datacube. Defaults to None.\n        channels_meta (dict | None, optional): The channels meta of the datacube. Defaults to None.\n        channels_encoding (dict | None, optional): The channels encoding of the datacube. Defaults to None.\n\n    Raises:\n        ValueError: If the storage is not an icechunk.Storage.\n\n    \"\"\"\n    if isinstance(storage, (str | Path)):\n        storage = storage if isinstance(storage, str) else str(storage.resolve())\n        storage = icechunk.local_filesystem_storage(storage)\n    if not isinstance(storage, icechunk.Storage):\n        raise ValueError(f\"Expected an icechunk.Storage, but got {type(storage)}\")\n    self.storage = storage\n    logger.debug(f\"Using storage {storage=}\")\n    if create_icechunk_storage:\n        self.repo = icechunk.Repository.open_or_create(storage)  # Will create a \"main\" branch\n    else:\n        self.repo = icechunk.Repository.open(storage)\n    logger.debug(f\"Using repository {self.repo=}\")\n\n    # We overwrite optionally the dataset attributes with user defined settings\n    self.title = title or type(self).__name__\n    if extent is not None:\n        self.extent = extent\n    if chunk_size is not None:\n        self.chunk_size = chunk_size\n    if channels is not None:\n        self.channels = channels\n    if channels_meta is not None:\n        self.channels_meta\n    if channels_encoding is not None:\n        self.channels_encoding\n\n    # TODO: store the settings variables in metadata and validate here\n\n    # The benchmarking timer for this accessor\n    self.stopuhr = StopUhr(logger.debug)\n\n    # The TypeVar used by the ThreadingHandler was added in 3.12\n    # The Shutdown method of the queue was added in 3.13\n    # Hence, we don't want to import the module unless Python 3.13 is installed\n    if _check_python_version(3, 13):\n        from smart_geocubes.concurrency.threading import ThreadingHandler\n\n        self.threading_handler = ThreadingHandler(self._threading_download)\n</code></pre>"},{"location":"reference/smart_geocubes/datasets/arcticdem/#smart_geocubes.datasets.arcticdem.ArcticDEMABC","title":"ArcticDEMABC","text":"<pre><code>ArcticDEMABC(\n    storage: Storage | Path | str,\n    create_icechunk_storage: bool = True,\n    title: str | None = None,\n    extent: GeoBox | None = None,\n    chunk_size: int | None = None,\n    channels: list | None = None,\n    channels_meta: dict | None = None,\n    channels_encoding: dict | None = None,\n)\n</code></pre> <p>               Bases: <code>STACAccessor</code></p> <p>ABC for Arcticdem data.</p> <p>Methods:</p> <ul> <li> <code>adjacent_tiles</code>             \u2013              <p>Get adjacent tiles from a STAC API.</p> </li> <li> <code>post_create</code>             \u2013              <p>Download the ArcticDEM mosaic extent info and store it in the datacube.</p> </li> <li> <code>visualize_state</code>             \u2013              <p>Visulize the extend, hence the already downloaded and filled data, of the datacube.</p> </li> </ul> Source code in <code>src/smart_geocubes/accessors/base.py</code> <pre><code>def __init__(\n    self,\n    storage: icechunk.Storage | Path | str,\n    create_icechunk_storage: bool = True,\n    title: str | None = None,\n    extent: GeoBox | None = None,\n    chunk_size: int | None = None,\n    channels: list | None = None,\n    channels_meta: dict | None = None,\n    channels_encoding: dict | None = None,\n):\n    \"\"\"Initialize base class for remote accessors.\n\n    !!! warning\n\n        In a multiprocessing environment, it is strongly recommended to not set `create_icechunk_storage=False`.\n\n    The arguments `title`, `extent`, `chunk_size`, `channels`, `channels_meta` and `channels_encoding`\n    will overwrite the dataset defaults and are only considered for the creation of a new datacube.\n    It is strongly recommended to not set these values manually.\n\n    Args:\n        storage (icechunk.Storage): The icechunk storage of the datacube.\n        create_icechunk_storage (bool, optional): If an icechunk repository should be created at provided storage\n            if no exists.\n            This should be disabled in a multiprocessing environment.\n            Defaults to True.\n        title (str | None, optional): The title of the datacube. Defaults to None.\n        extent (GeoBox | None, optional): The extent of the datacube. Defaults to None.\n        chunk_size (int | None, optional): The chunk size of the datacube. Defaults to None.\n        channels (list | None, optional): The channels of the datacube. Defaults to None.\n        channels_meta (dict | None, optional): The channels meta of the datacube. Defaults to None.\n        channels_encoding (dict | None, optional): The channels encoding of the datacube. Defaults to None.\n\n    Raises:\n        ValueError: If the storage is not an icechunk.Storage.\n\n    \"\"\"\n    if isinstance(storage, (str | Path)):\n        storage = storage if isinstance(storage, str) else str(storage.resolve())\n        storage = icechunk.local_filesystem_storage(storage)\n    if not isinstance(storage, icechunk.Storage):\n        raise ValueError(f\"Expected an icechunk.Storage, but got {type(storage)}\")\n    self.storage = storage\n    logger.debug(f\"Using storage {storage=}\")\n    if create_icechunk_storage:\n        self.repo = icechunk.Repository.open_or_create(storage)  # Will create a \"main\" branch\n    else:\n        self.repo = icechunk.Repository.open(storage)\n    logger.debug(f\"Using repository {self.repo=}\")\n\n    # We overwrite optionally the dataset attributes with user defined settings\n    self.title = title or type(self).__name__\n    if extent is not None:\n        self.extent = extent\n    if chunk_size is not None:\n        self.chunk_size = chunk_size\n    if channels is not None:\n        self.channels = channels\n    if channels_meta is not None:\n        self.channels_meta\n    if channels_encoding is not None:\n        self.channels_encoding\n\n    # TODO: store the settings variables in metadata and validate here\n\n    # The benchmarking timer for this accessor\n    self.stopuhr = StopUhr(logger.debug)\n\n    # The TypeVar used by the ThreadingHandler was added in 3.12\n    # The Shutdown method of the queue was added in 3.13\n    # Hence, we don't want to import the module unless Python 3.13 is installed\n    if _check_python_version(3, 13):\n        from smart_geocubes.concurrency.threading import ThreadingHandler\n\n        self.threading_handler = ThreadingHandler(self._threading_download)\n</code></pre>"},{"location":"reference/smart_geocubes/datasets/arcticdem/#smart_geocubes.datasets.arcticdem.ArcticDEMABC.adjacent_tiles","title":"adjacent_tiles","text":"<pre><code>adjacent_tiles(geobox: GeoBox) -&gt; list[TileWrapper]\n</code></pre> <p>Get adjacent tiles from a STAC API.</p> <p>Overwrite the default implementation from the STAC accessor to use pre-downloaded extent files instead of querying the STAC API. This results in a faster loading time, but requires the extent files to be downloaded beforehand. This is done in the post_create step.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[TileWrapper]</code>           \u2013            <p>list[TileWrapper]: List of adjacent tiles, wrapped in own datastructure for easier processing.</p> </li> </ul> Source code in <code>src/smart_geocubes/datasets/arcticdem.py</code> <pre><code>def adjacent_tiles(self, geobox: GeoBox) -&gt; list[TileWrapper]:\n    \"\"\"Get adjacent tiles from a STAC API.\n\n    Overwrite the default implementation from the STAC accessor\n    to use pre-downloaded extent files instead of querying the STAC API.\n    This results in a faster loading time, but requires the extent files to be downloaded beforehand.\n    This is done in the post_create step.\n\n    Args:\n        geobox (GeoBox): The geobox for which to get adjacent tiles.\n\n    Returns:\n        list[TileWrapper]: List of adjacent tiles, wrapped in own datastructure for easier processing.\n\n    \"\"\"\n    # Assumes that the extent files are already present and the datacube is already created\n    self.assert_created()\n\n    resolution = int(self.extent.resolution.x)\n    extent_info = gpd.read_parquet(self._aux_dir / f\"ArcticDEM_Mosaic_Index_v4_1_{resolution}m.parquet\")\n    adjacent_tiles = extent_info.loc[extent_info.intersects(geobox.extent.geom)].copy()\n    if adjacent_tiles.empty:\n        return []\n    return [LazyStacTileWrapper(tile.dem_id, _get_stac_url(tile.dem_id)) for tile in adjacent_tiles.itertuples()]\n</code></pre>"},{"location":"reference/smart_geocubes/datasets/arcticdem/#smart_geocubes.datasets.arcticdem.ArcticDEMABC.adjacent_tiles(geobox)","title":"<code>geobox</code>","text":"(<code>GeoBox</code>)           \u2013            <p>The geobox for which to get adjacent tiles.</p>"},{"location":"reference/smart_geocubes/datasets/arcticdem/#smart_geocubes.datasets.arcticdem.ArcticDEMABC.post_create","title":"post_create","text":"<pre><code>post_create()\n</code></pre> <p>Download the ArcticDEM mosaic extent info and store it in the datacube.</p> Source code in <code>src/smart_geocubes/datasets/arcticdem.py</code> <pre><code>def post_create(self):\n    \"\"\"Download the ArcticDEM mosaic extent info and store it in the datacube.\"\"\"\n    _download_arcticdem_extent(self._aux_dir)\n</code></pre>"},{"location":"reference/smart_geocubes/datasets/arcticdem/#smart_geocubes.datasets.arcticdem.ArcticDEMABC.visualize_state","title":"visualize_state","text":"<pre><code>visualize_state(\n    ax: Axes | None = None,\n) -&gt; plt.Figure | plt.Axes\n</code></pre> <p>Visulize the extend, hence the already downloaded and filled data, of the datacube.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Figure | Axes</code>           \u2013            <p>plt.Figure | plt.Axes: The figure with the visualization if no axes was provided, else the axes.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the datacube is empty</p> </li> </ul> Source code in <code>src/smart_geocubes/datasets/arcticdem.py</code> <pre><code>def visualize_state(self, ax: \"plt.Axes | None\" = None) -&gt; \"plt.Figure | plt.Axes\":\n    \"\"\"Visulize the extend, hence the already downloaded and filled data, of the datacube.\n\n    Args:\n        ax (plt.Axes | None): The axes drawn to. If None, will create a new figure and axes.\n\n    Returns:\n        plt.Figure | plt.Axes: The figure with the visualization if no axes was provided, else the axes.\n\n    Raises:\n        ValueError: If the datacube is empty\n\n    \"\"\"\n    import cartopy.crs as ccrs\n    import cartopy.feature as cfeature\n    import matplotlib.path as mpath\n    import matplotlib.pyplot as plt\n\n    tile_info = self.current_state()\n\n    if tile_info is None:\n        raise ValueError(\"Datacube is not created or loaded yet. Can't visualize!\")\n\n    # Define the projection\n    projection = ccrs.Stereographic(central_latitude=90, central_longitude=-45, true_scale_latitude=70)\n\n    # Create a figure\n    fig = None\n    if ax is None:\n        fig, ax = plt.subplots(figsize=(10, 10), subplot_kw={\"projection\": projection})\n\n    # Set the extent to focus on the North Pole\n    ax.set_extent([-180, 180, 50, 90], crs=ccrs.PlateCarree())\n\n    # Add features\n    ax.add_feature(cfeature.LAND, zorder=0, edgecolor=\"black\", facecolor=\"white\")\n    ax.add_feature(cfeature.OCEAN, zorder=0, facecolor=\"lightgrey\")\n    ax.add_feature(cfeature.COASTLINE)\n    ax.add_feature(cfeature.BORDERS, linestyle=\":\")\n    ax.add_feature(cfeature.LAKES, alpha=0.5)\n    ax.add_feature(cfeature.RIVERS)\n\n    # Add gridlines\n    gl = ax.gridlines(draw_labels=True)\n    gl.top_labels = False\n    gl.right_labels = False\n\n    # Compute a circle in axes coordinates, which we can use as a boundary\n    # for the map. We can pan/zoom as much as we like - the boundary will be\n    # permanently circular.\n    theta = np.linspace(0, 2 * np.pi, 100)\n    center, radius = [0.5, 0.5], 0.5\n    verts = np.vstack([np.sin(theta), np.cos(theta)]).T\n    circle = mpath.Path(verts * radius + center)\n\n    ax.set_boundary(circle, transform=ax.transAxes)\n\n    tile_info.plot(\n        \"title\",\n        ax=ax,\n        transform=ccrs.PlateCarree(),\n        edgecolor=\"black\",\n        categorical=True,\n        aspect=\"equal\",\n        alpha=0.5,\n    )\n\n    if fig is not None:\n        return fig\n    else:\n        return ax\n</code></pre>"},{"location":"reference/smart_geocubes/datasets/arcticdem/#smart_geocubes.datasets.arcticdem.ArcticDEMABC.visualize_state(ax)","title":"<code>ax</code>","text":"(<code>Axes | None</code>, default:                   <code>None</code> )           \u2013            <p>The axes drawn to. If None, will create a new figure and axes.</p>"},{"location":"reference/smart_geocubes/datasets/arcticdem/#smart_geocubes.datasets.arcticdem.LazyStacTileWrapper","title":"LazyStacTileWrapper","text":"<pre><code>LazyStacTileWrapper(tile_id: str, stac_file: str)\n</code></pre> <p>Lazy wrapper for a TileWrapper containing a STAC Item.</p> <p>This is necessary since the download function of the STAC accessor expects a TileWrapper object containing a pystac.Item.</p> <p>However, creating such a pystac Item always fetches the metadata from the STAC API. For just loading the ArcticDEM data, we don't need this pystac Item. Hence, we create it lazily when it is actually needed.</p> Source code in <code>src/smart_geocubes/datasets/arcticdem.py</code> <pre><code>def __init__(self, tile_id: str, stac_file: str):  # noqa: D107\n    self.id = tile_id\n    self.stac_file = stac_file\n</code></pre>"},{"location":"reference/smart_geocubes/datasets/tctrend/","title":"smart_geocubes.datasets.tctrend","text":""},{"location":"reference/smart_geocubes/datasets/tctrend/#smart_geocubes.datasets.tctrend","title":"smart_geocubes.datasets.tctrend","text":"<p>Predefined accessor for TCTrend data.</p> <p>Classes:</p> <ul> <li> <code>TCTrend</code>           \u2013            <p>Accessor for TCTrend data.</p> </li> </ul>"},{"location":"reference/smart_geocubes/datasets/tctrend/#smart_geocubes.datasets.tctrend.TCTrend","title":"TCTrend","text":"<pre><code>TCTrend(\n    storage: Storage | Path | str,\n    create_icechunk_storage: bool = True,\n    title: str | None = None,\n    extent: GeoBox | None = None,\n    chunk_size: int | None = None,\n    channels: list | None = None,\n    channels_meta: dict | None = None,\n    channels_encoding: dict | None = None,\n)\n</code></pre> <p>               Bases: <code>GEEAccessor</code></p> <p>Accessor for TCTrend data.</p> <p>Methods:</p> <ul> <li> <code>visualize_state</code>             \u2013              <p>Visulize the extend, hence the already downloaded and filled data, of the datacube.</p> </li> </ul> Source code in <code>src/smart_geocubes/accessors/base.py</code> <pre><code>def __init__(\n    self,\n    storage: icechunk.Storage | Path | str,\n    create_icechunk_storage: bool = True,\n    title: str | None = None,\n    extent: GeoBox | None = None,\n    chunk_size: int | None = None,\n    channels: list | None = None,\n    channels_meta: dict | None = None,\n    channels_encoding: dict | None = None,\n):\n    \"\"\"Initialize base class for remote accessors.\n\n    !!! warning\n\n        In a multiprocessing environment, it is strongly recommended to not set `create_icechunk_storage=False`.\n\n    The arguments `title`, `extent`, `chunk_size`, `channels`, `channels_meta` and `channels_encoding`\n    will overwrite the dataset defaults and are only considered for the creation of a new datacube.\n    It is strongly recommended to not set these values manually.\n\n    Args:\n        storage (icechunk.Storage): The icechunk storage of the datacube.\n        create_icechunk_storage (bool, optional): If an icechunk repository should be created at provided storage\n            if no exists.\n            This should be disabled in a multiprocessing environment.\n            Defaults to True.\n        title (str | None, optional): The title of the datacube. Defaults to None.\n        extent (GeoBox | None, optional): The extent of the datacube. Defaults to None.\n        chunk_size (int | None, optional): The chunk size of the datacube. Defaults to None.\n        channels (list | None, optional): The channels of the datacube. Defaults to None.\n        channels_meta (dict | None, optional): The channels meta of the datacube. Defaults to None.\n        channels_encoding (dict | None, optional): The channels encoding of the datacube. Defaults to None.\n\n    Raises:\n        ValueError: If the storage is not an icechunk.Storage.\n\n    \"\"\"\n    if isinstance(storage, (str | Path)):\n        storage = storage if isinstance(storage, str) else str(storage.resolve())\n        storage = icechunk.local_filesystem_storage(storage)\n    if not isinstance(storage, icechunk.Storage):\n        raise ValueError(f\"Expected an icechunk.Storage, but got {type(storage)}\")\n    self.storage = storage\n    logger.debug(f\"Using storage {storage=}\")\n    if create_icechunk_storage:\n        self.repo = icechunk.Repository.open_or_create(storage)  # Will create a \"main\" branch\n    else:\n        self.repo = icechunk.Repository.open(storage)\n    logger.debug(f\"Using repository {self.repo=}\")\n\n    # We overwrite optionally the dataset attributes with user defined settings\n    self.title = title or type(self).__name__\n    if extent is not None:\n        self.extent = extent\n    if chunk_size is not None:\n        self.chunk_size = chunk_size\n    if channels is not None:\n        self.channels = channels\n    if channels_meta is not None:\n        self.channels_meta\n    if channels_encoding is not None:\n        self.channels_encoding\n\n    # TODO: store the settings variables in metadata and validate here\n\n    # The benchmarking timer for this accessor\n    self.stopuhr = StopUhr(logger.debug)\n\n    # The TypeVar used by the ThreadingHandler was added in 3.12\n    # The Shutdown method of the queue was added in 3.13\n    # Hence, we don't want to import the module unless Python 3.13 is installed\n    if _check_python_version(3, 13):\n        from smart_geocubes.concurrency.threading import ThreadingHandler\n\n        self.threading_handler = ThreadingHandler(self._threading_download)\n</code></pre>"},{"location":"reference/smart_geocubes/datasets/tctrend/#smart_geocubes.datasets.tctrend.TCTrend.visualize_state","title":"visualize_state","text":"<pre><code>visualize_state(\n    ax: Axes | None = None,\n) -&gt; plt.Figure | plt.Axes\n</code></pre> <p>Visulize the extend, hence the already downloaded and filled data, of the datacube.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Figure | Axes</code>           \u2013            <p>plt.Figure | plt.Axes: The figure with the visualization if no axes was provided, else the axes.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the datacube is empty</p> </li> </ul> Source code in <code>src/smart_geocubes/datasets/tctrend.py</code> <pre><code>def visualize_state(self, ax: \"plt.Axes | None\" = None) -&gt; \"plt.Figure | plt.Axes\":\n    \"\"\"Visulize the extend, hence the already downloaded and filled data, of the datacube.\n\n    Args:\n        ax (plt.Axes | None): The axes drawn to. If None, will create a new figure and axes.\n\n    Returns:\n        plt.Figure | plt.Axes: The figure with the visualization if no axes was provided, else the axes.\n\n    Raises:\n        ValueError: If the datacube is empty\n\n    \"\"\"\n    import cartopy.crs as ccrs\n    import cartopy.feature as cfeature\n    import matplotlib.pyplot as plt\n\n    tile_info = self.current_state()\n\n    if tile_info is None:\n        raise ValueError(\"Datacube is not created or loaded yet. Can't visualize!\")\n\n    # Define the projection\n    projection = ccrs.PlateCarree()\n\n    # Create a figure\n    fig = None\n    if ax is None:\n        fig, ax = plt.subplots(figsize=(10, 10), subplot_kw={\"projection\": projection})\n\n    # Set the extent to show the whole world\n    ax.set_extent([-180, 180, -90, 90], crs=ccrs.PlateCarree())\n\n    # Add features\n    ax.add_feature(cfeature.LAND, zorder=0, edgecolor=\"black\", facecolor=\"white\")\n    ax.add_feature(cfeature.OCEAN, zorder=0, facecolor=\"lightgrey\")\n    ax.add_feature(cfeature.COASTLINE)\n    ax.add_feature(cfeature.BORDERS, linestyle=\":\")\n    ax.add_feature(cfeature.LAKES, alpha=0.5)\n    ax.add_feature(cfeature.RIVERS)\n\n    # Add gridlines\n    gl = ax.gridlines(draw_labels=True)\n    gl.top_labels = False\n    gl.right_labels = False\n\n    tile_info.plot(\n        \"id\",\n        ax=ax,\n        transform=ccrs.PlateCarree(),\n        edgecolor=\"black\",\n        categorical=True,\n        aspect=\"equal\",\n        alpha=0.5,\n    )\n\n    if fig is not None:\n        return fig\n    else:\n        return ax\n</code></pre>"},{"location":"reference/smart_geocubes/datasets/tctrend/#smart_geocubes.datasets.tctrend.TCTrend.visualize_state(ax)","title":"<code>ax</code>","text":"(<code>Axes | None</code>, default:                   <code>None</code> )           \u2013            <p>The axes drawn to. If None, will create a new figure and axes.</p>"},{"location":"reference/smart_geocubes/storage/","title":"smart_geocubes.storage","text":""},{"location":"reference/smart_geocubes/storage/#smart_geocubes.storage","title":"smart_geocubes.storage","text":"<p>Local zarr-storage related functions.</p> <p>Classes:</p> <ul> <li> <code>CoordEncoding</code>           \u2013            <p>TypedDict for the encoding of regularly spaced coordinates.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>optimize_coord_encoding</code>             \u2013              <p>Optimize zarr encoding of regularly spaced coordinates.</p> </li> </ul>"},{"location":"reference/smart_geocubes/storage/#smart_geocubes.storage.CoordEncoding","title":"CoordEncoding","text":"<p>               Bases: <code>TypedDict</code></p> <p>TypedDict for the encoding of regularly spaced coordinates.</p>"},{"location":"reference/smart_geocubes/storage/#smart_geocubes.storage.optimize_coord_encoding","title":"optimize_coord_encoding","text":"<pre><code>optimize_coord_encoding(\n    values: ndarray, dx: int\n) -&gt; CoordEncoding\n</code></pre> <p>Optimize zarr encoding of regularly spaced coordinates.</p> <p>Taken from https://github.com/earth-mover/serverless-datacube-demo/blob/a15423b9734898f52468bebc441e29ccf3789410/src/lib.py#L280</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>CoordEncoding</code> (              <code>CoordEncoding</code> )          \u2013            <p>A dictionary containing the zarr compressors and filters to use for encoding the coordinates.</p> </li> </ul> Source code in <code>src/smart_geocubes/storage.py</code> <pre><code>def optimize_coord_encoding(values: np.ndarray, dx: int) -&gt; CoordEncoding:\n    \"\"\"Optimize zarr encoding of regularly spaced coordinates.\n\n    Taken from https://github.com/earth-mover/serverless-datacube-demo/blob/a15423b9734898f52468bebc441e29ccf3789410/src/lib.py#L280\n\n    Args:\n        values (np.ndarray): The coordinates to encode\n        dx (int): The spacing between the coordinates\n\n    Returns:\n        CoordEncoding: A dictionary containing the zarr compressors and filters to use for encoding the coordinates.\n\n    \"\"\"\n    dx_all = np.diff(values)\n    # dx = dx_all[0]\n    np.testing.assert_allclose(dx_all, dx), \"must be regularly spaced\"\n\n    offset_codec = FixedScaleOffset(offset=values[0], scale=1 / dx, dtype=values.dtype, astype=\"&lt;i8\")\n    delta_codec = Delta(dtype=\"&lt;i8\", astype=\"&lt;i2\")\n    compressor = BloscCodec()\n\n    # Since the update to zarr 3., we can't test the encoding and decoding in a simple maner anymore\n    # because they use async operations etc.\n    # enc0 = offset_codec.encode(values)\n    # everything should be offset by 1 at this point\n    # np.testing.assert_equal(np.unique(np.diff(enc0)), [1])\n    # enc1 = delta_codec.encode(enc0)\n    # now we should be able to compress the shit out of this\n    # enc2 = compressor.encode(enc1)\n    # decoded = offset_codec.decode(delta_codec.decode(compressor.decode(enc2)))\n    # will produce numerical precision differences\n    # np.testing.assert_equal(values, decoded)\n    # np.testing.assert_allclose(values, decoded)\n\n    return {\"compressors\": [compressor], \"filters\": [offset_codec, delta_codec]}\n</code></pre>"},{"location":"reference/smart_geocubes/storage/#smart_geocubes.storage.optimize_coord_encoding(values)","title":"<code>values</code>","text":"(<code>ndarray</code>)           \u2013            <p>The coordinates to encode</p>"},{"location":"reference/smart_geocubes/storage/#smart_geocubes.storage.optimize_coord_encoding(dx)","title":"<code>dx</code>","text":"(<code>int</code>)           \u2013            <p>The spacing between the coordinates</p>"}]}